
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Synchronet Message Base Specification</title>
</head>

<body>
<!--webbot bot="Include" U-Include="_borders/top.htm" TAG="BODY" startspan -->

<a href="http://www.synchro.net"><img border="0" src="images/synclogo_fancyred.gif" alt="Synchronet BBS - Multinode Bulletin Board Software" width="626" height="86"></a>

<hr>

<!--webbot bot="Include" endspan i-CheckSum="23126" -->
<h1><a name="top">Synchronet Message Base Specification</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>Version 1.21</i></h1>
<h4><a name="toc"><b>Table of Contents</b></a></h4>
<div align="left">
  <pre><a href="#Introduction">Introduction</a>
<a href="#Implementation Levels">Implementation Levels</a>
<a href="#Definitions">Definitions</a>
        <a href="#Acronyms:">Acronyms</a>
        <a href="#Data types">Data Types</a>
<a href="#File Formats">File Formats</a>
        <a href="#Index File (*.SID)">Index</a>			(*.SID)
        <a href="#Header File (*.SHD)">Header</a>			(*.SHD)
        <a href="#Message Header Block Allocation (*.SHA)">Header Allocation</a>	(*.SHA)
        <a href="#Message Data (*.SDT)">Data</a>			(*.SDT)
        <a href="#Message Data Block Allocation (*.SDA)">Data Allocation</a>		(*.SDA)
        <a href="#CRC history for duplicate message checking (*.SCH)">CRC History</a>		(*.SCH)
<a href="#Header Field Types:">Header Field Types</a>
<a href="#Data Field Types:">Data Field Types</a>
<a href="#Message Attributes:">Messsage Attributes</a>
<a href="#Translation Types:">Translation Types</a>
<a href="#Agent Types:">Agent Types</a>
<a href="#Network Types:">Network Types</a>
<a href="#Media Types:">Media Types</a>
<a href="#Message Storage Pseudo Code">Message Storage Pseudo Code</a>
<a href="#Message Retrieval Pseudo Code">Message Retrieval Pseudo Code</a>
<a href="#SMBUTIL">SMBUTIL</a>
<a href="#CHKSMB">CHKSMB</a>
<a href="#FIXSMB">FIXSMB</a>
<a href="#SMBLIB">SMBLIB (C library)</a>
        <a href="#SMBDEFS.H">Data Types and Constants</a>	(SMBDEFS.H)
        <a href="#SMBVARS.C">Global Variables</a>		(SMBVARS.C)
        <a href="#SMBLIB.H">Function Prototypes</a>		(SMBLIB.H)
        <a href="#SMBLIB.C">Library Functions</a>		(SMBLIB.C)
        <a href="#Miscellaneous SMBLIB Files">Miscellaneous</a>			(CRC*.* and LZH.*)
<a href="#SMBLIB Storage Example">SMBLIB Storage Example</a>
<a href="#SMBLIB Retrieval Example">SMBLIB Retrieval Example</a>
<a href="#SMBLIB Performance Issues">SMBLIB Performance Issues</a>
<a href="#Bibliography">Bibliography</a></pre>
</div>
<h2><u><a name="Introduction">Introduction</a></u></h2>
<pre><b><i>Q. What is SMB?</i></b></pre>
<pre>A. SMB (Synchronet Message Base) is a technical specification for the storage
   format of electronic mail messages. These e-mail messages may all be
   contained in one database, or, more commonly, separated into catagorized
   databases. These message databases (or message bases) are also referred to
   as &quot;sub-boards&quot;, &quot;forums&quot;, &quot;conferences&quot;, and &quot;SIGs&quot;. The messages may be
   directed to an individual person, sent to a group of individuals, or sent
   to everyone who can read messages in that message base. Messages may be
   created and read soley at one physical location, or imported from and
   exported to a message network that may span continents. Message bases that
   are connected to a message network are often called &quot;echoes&quot;.
</pre>
<pre><b><i>Q. Why SMB?</i></b></pre>
<pre>A. The Synchronet Message Base is designed to store high volumes of messages
   while maintaining optimum search, retrieval, and creation performance.
   These messages are not limited to mere text. In addition to text, SMB
   defines the storage of digitized sound, MIDI, graphics, fonts, animation,
   as well as other multimedia data and triggers for localized multimedia.
   SMB thrives on a multi-user environment where messages are being created,
   read, modified, and deleted by multiple tasks simultaneously. With the
   large message networks of today being the rule, rather than the exception,
   and high volumes of messages being imported on a daily, sometimes hourly
   basis, creation and deletion speed is of the utmost importance. This is
   where SMB really shines. Being extensible enough to handle message formats
   from networks of today and tomorrow, and fast enough to import more messages
   that humanly readable, the SMB format will more than meet your message
   storage needs.
</pre>
<pre><b><i>Q. Why a specification?</i></b></pre>
<pre>A. Message bases are often accessed and modified by a number of different
   programs. Often these programs are developed by individuals or companies
   other than the original designer of the message base format. This
   specification is an attempt to aid developers in creating programs that
   access or modify a message base stored in the SMB format.
</pre>
<pre><b><i>Q. Who can use this specification?</i></b></pre>
<pre>A. Anyone that has interest in the Synchronet Message Base format at either
   an educational or professional level. Specifically, software developers
   interested or currently involved in the development of message readers,
   editors, echomail (toss/scan) programs, message transfer agents (MTAs),
   network gateways, and bulletin board systems. Much of the information in
   this specification is intended for those with preexisting programming
   knowledge, so those with little or no programming experience may find it
   hard to comprehend.</pre>
<pre><b><i>Q. What does the SMB specification include?</i></b></pre>
<pre>A. The text you are reading is part of the SMB specification: a single text
   document that defines the storage format of each of the six files of an
   SMB format message base and how they are related to each other.</pre>
<pre>   Included with this specification is C source code to be used as an example
   to programmers of how to access an SMB format message base and public domain
   library functions (SMBLIB) that can be compiled and linked into programs
   that access an SMB format message base developed by third parties. An SMB
   utility program (SMBUTIL) is also included with C source code as an example
   of how to use the SMBLIB functions.
</pre>
<pre><b><i>Q. Where did the SMB specification come from?</i></b></pre>
<pre>A. Digital Dynamics (southern California based software development company)
   released &quot;Synchronet Multinode BBS Software Version 1a&quot; in June of 1992 as
   one of the first BBS packages to be designed from the ground-up to operate
   in a multinode environment with incredible speed and reliability, with a
   large suite of multinode specific features and design innovations.</pre>
<pre>   The original message base format was designed with localized messaging and
   low volume message networks in mind. By January of 1993, it was clear that
   high volume message networks (FidoNet, RelayNet, Usenet, etc.) were the
   preference of most BBS users and a new message base format was required to
   allow for high volume message storage, improved storage, retrieval, and
   maintenance performance, as well as lower storage space requirements.</pre>
<pre>   Rather than introduce another new message format, Digital Dynamics sought
   to implement an existing public specification for a format that would meet
   current and future message storage needs. More than a few specifications
   were seriously considered at one time or another, but after careful
   examination, design flaws and lack of extensibility eliminated them from the
   long term plans of Digital Dynamics and Synchronet BBS Software. Thus began
   the design of the &quot;Synchronet Message Base&quot; (SMB) format.</pre>
<pre>   At the request of many message related program developers, Digital Dynamics
   created and released the SMB specification before the release of &quot;Synchronet
   Version 2.00&quot; to allow lead-time on developing support programs for the new
   format.</pre>
<pre>   Digital Dynamics strongly encourages developers of message related programs
   (including software that directly competes with Synchronet or other Digital
   Dynamics products) to implement support for SMB. Though this is a public
   specification and Digital Dynamics encourages developer suggestions, it will
   remain under the sole control of Digital Dynamics unless specifically stated
   otherwise in a future revision of this specification.</pre>
<pre>   Digital Dynamics requests that any organizations that wish to adopt or
   ratify this specification, in part or whole, notify Digital Dynamics through
   any of the contact methods listed at the beginning of this document.</pre>
<pre><b><i>Q. How does SMB store messages?</i></b></pre>
<pre>A. Each message base is stored in a set of binary files. This set consists
   of between three and six files depending the storage method used. The base
   filename (maximum of eight characters under DOS) is the same for all six
   files of the same message base and unique amoung the filenames of other
   message bases in the same directory. The six files each have a different
   three character extension. The first character of the extension is always
   the letter 'S' (for SMB), while the second and third characters define the
   contents of the file.</pre>
<pre>   Two of the six files associated with each message base are not recreatable
   and therefore are the most important when considering data integrity. These
   two files are the data file (with a .SDT extension) and header file (.SHD
   extension). Both of these files use 256 byte blocks and have associated
   block allocation tables (stored in .SDA and .SHA respectively) so that
   deleted message blocks may be used by new messages without creating odd
   sized unused 'holes' in the files. The block allocation table files (.SDA
   and .SHA) can be recreated with the information stored in the header (.SHD)
   file. When using Hyper Allocation storage method, the allocation files (.SDA
   and .SHA) are not used.</pre>
<pre>   For fast indexing, there is a small fixed length index file (with a .SID
   extension). This file allows for the immediate location of message header
   records based on sender's name or user number, recipient's name or user
   number, subject, message number, or message attributes. This file can be
   recreated with the data stored in the header (.SHD) file.</pre>
<pre>   The last file is an optional CRC history (.SCH) file. It contains 32-bit
   CRCs of a configurable number of messages imported or created locally. This
   is to help eliminate duplicate messages created by user or program error.
   The CRC history file can be recreated with the combination of information
   stored in the data (.SDT) and header (.SHD) files.

<b><i>Q. How fast do messages import into an SMB message base?</i></b></pre>
<pre>A. This is a very important question for systems for that import large volumes
   of messages. Of course, the answer depends on the storage format which you
   are importing from, the average length of messages, the design of the
   program which is peforming the import process, as well as the hardware and
   system software being used. What's important is that SMB will allow the
   fastest import process possible with any given combination of the above
   factors.</pre>
<pre>   Since system storage capacity is rarely infinite, neither is the number
   of messages which can be stored in a message base. System operators must
   define the maximum number of messages to be stored in a message base, the
   maximum age of the messages in that message base, or a combination of both.
   When using the Self-packing storage method (defined later in this document),
   the smaller the number of messages stored in a message base, the faster the
   import process. The SMB format is flexible enough to support multiple levels
   of import performance based on optimizations for storage space or speed.
   Most system operators will almost invariably choose speed over space, but
   which choices are available is determined by the importing program. This
   specification defines three storage methods, from slowest to fastest:
   Self-packing, Fast Allocation, and Hyper Allocation. Other options defined
   in this specification may affect storage performance, including duplicate
   message checking and message compression/encryption.
</pre>
<pre><b><i>Q. How much storage is required for an SMB message base?</i></b></pre>
<pre>A. The biggest factor in determining storage requirements for a message base
   is the maximum number of messages to be stored in the base (defined by the
   system operator) and the average size of each message. The minimum required
   storage for a message base is 32 bytes plus 532 bytes per message (plus four
   bytes per message if duplicate message checking is used and three bytes
   per message if Self-packing or Fast Allocation storage methods are used).</pre>
<pre>   The SMB format was originally designed to be &quot;self-packing&quot;, meaning purged
   (deleted) message header and data blocks will be used automatically by new
   messages. Relying solely on self-packing, an SMB format message base will
   never &quot;shrink&quot; in size. This is not to say that it will continually &quot;grow&quot;
   in size, but that without specific packing procedures, deleted message
   blocks may remain unused for extended periods of time, meanwhile using some
   amount of storage space that could be recovered using specific packing
   procedures. The Fast Allocation and Hyper Allocation storage methods do not
   use deleted message blocks for new messages so specific packing procedures
   must be used if any messages are deleted and that storage space is to ever
   be recovered.</pre>
<pre>   Limiting the maximum age of messages in an SMB message base is another way
   to control the storage requirements. While maximum message age definition is
   optional, the definition of the maximum number of messages is not.

<b><i>Q. How many messages can be stored per SMB message base?</i></b></pre>
<pre>A. Without considering storage limitations or message data lengths greater than
   256, the theoretical maximum number of messages that can be stored in a
   single SMB message base is 16.7 million. Considering the variable length
   nature of message and header data, it is suggested that the system operator
   allow no more than 1 million messages per base.</pre>
<pre>   To determine an estimated maximum number of messages for a message base
   using the average message data length as a factor, use the following
   formula:</pre>
<pre>   4.2 billion divided by the average message length rounded up to be evenly
   divisible by 256.</pre>
<pre>   If the average message data length is 1500 bytes, the estimated maximum
   number of messages would be 2,734,375 (4.2 billion divided by 1536).</pre>
<pre>   Implementations of this format may be further limited by available system
   memory.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Implementation Levels">Implementation Levels</a></u></h2>
<pre>The SMB format can be implemented to varying degrees between programs without
creating compatibilty issues. Rather than have developers specifically state
which features they have and have not implemented, we have defined seven levels
of implementation (represented by Roman numerals I through VII). For a program
or software package to meet an implementation level, it must have all of the
features listed for that level and all of those for each level below it. The
minimum suggested imlementation is level I. The SMBUTIL program included with
this specification is an example of a level I implementation with features
from some of the higher implementation levels.</pre>
<pre><b><u>Level I</u></b>

The minimum suggested level of implementation. Messages contain merely ASCII
text displayable on an ANSI terminal. Messages can be added to the message
base and if the maximum number of messages is exceeded, messages are removed
or marked for deletion.</pre>
<pre><b><u>Level II</u></b>

The addition of file attachments, multiple index/header entries per message
(multiple destinations), multiple text bodies for the separation of message
text and tag/origin lines (for example), forwarding, threading, and specific
FidoNet kludge header field support makes this level of implementation more
realistic for bulletin board system and EchoMail software implementation.</pre>
<pre>Synchronet Multinode BBS Software v2.00 has a level II implementation of this
specification.</pre>
<pre><b><u>Level III</u></b>

This implementation adds support for translation strings defined later in this
document for data compression, encryption, escaping, and encoding. This level
is still limited to basic ASCII text and ANSI escape sequence entry and
retrieval.</pre>
<pre>Synchronet Multinode BBS Software v2.10 has a level III implementation of this
specification.</pre>
<pre><b><u>Level IV</u></b>

The storage and retrieval of embedded and attached images is added in this
level of implementation. Supported images are limited to single binary or text
data blocks that can be displayed or transferred to the user (automatically,
or by request) if their display and translation protocols define specific
support for the image type.

<b><u>Level V</u></b>

This level of implementation adds support for embedded and attached sound data.
This includes digitized sound and MIDI data. Supported sounds are limited to
single binary or text data blocks that can be played or transferred to the user
(automatically or by request) if their presentation and translation protocols
define specific support for the sound type.</pre>
<pre><b><u>Level VI
</u></b>
Localized sound and image data can be triggered by messages stored and
retrieved in an implementation of this level.</pre>
<pre><b><u>Level VII</u></b>

Complete multimedia support is reached in this implementation level with
support for embedded and attached animation, sound, and video data.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Definitions">Definitions</a></u></h2>
<pre><u><b>Control Characters</b></u></pre>
<pre>When specifying control characters (ASCII 1 through 31), the caret symbol &quot;^&quot;
or the abreviation &quot;ctrl-&quot; followed by a character will be used to indicate the
value. ^A is equivalent to ASCII 1, ^B ASCII 2, etc. The case of the control
character is not significant (i.e. ^z and ^Z are equivalent). The control
character ^@ (ASCII 0) will be specified as NULL or 0.
</pre>
<pre><b><u>Hexadecimal</u></b>

Base sixteen numbering system which includes the digits 0-9 and A-F.
Hexadecimal numbers are represented in this document with a prefix of &quot;0x&quot; or
&quot;\x&quot; or a suffix of &quot;h&quot;. Hexadecimal letter digits are not case sensitive
(i.e. the number 0xff is the same as 0xFF).
</pre>
<pre><b><u>File dump</u></b>

When example file dumps are displayed, the format is similar to that of the
output from the DOS DEBUG program. With the exception of the ASCII characters,
all numbers are in hexadecimal.</pre>
<pre>Offset    Byte values                                          ASCII characters</pre>
<pre>000000    53 4D 42 1A 10 01 20 00   F4 01 00 00 F4 01 00 00    SMB... .........
000010    20 00 00 00 D0 07 00 00   D0 07 00 00 00 00 00 00     ...............
</pre>
<pre><b><u>Bit values</u></b>

Bit (or flag) values are represented in C notation as (1&lt;&lt;x) where x is the bit
number. (i.e. bit number 7 (1&lt;&lt;7) is the same as 0x80).
</pre>
<pre><b><u>Word storage</u></b>

All words (16-bit) and double words (32-bit) are stored in Intel 80x86 (little
endian) format with bytes stored from low to high (reverse of the Motorola
680x0 word storage format).</pre>
<pre>A 16-bit word with the value 1234h is stored as 34h 12h.

<b><u>Translation strings</u></b>

Translation strings (xlat variables) are arrays of words (16-bit) in the order
of the original storage translation. The last translation type is followed by a
16-bit zero (defined later as XLAT_NONE). If there are no translations, then
the first and only element of the array is XLAT_NONE.</pre>
<pre>If multiple translations are used, the translation order must be reversed
upon retrieval to obtain the proper data.
</pre>
<pre><b><u>Local e-mail</u></b>

When referring to the local e-mail message base of a Synchronet BBS, we are
referring specifically to the message base with the name &quot;MAIL&quot; stored in the
&quot;DATA&quot; directory (e.g. \SBBS\DATA\MAIL).</pre>
<pre>Messages stored in this message base are different in the following respects:</pre>
<ul>
  <li>
<pre>The SMB_EMAIL status header attribute is set ON</pre>
  </li>
  <li>
<pre>Hyper Allocation storage method is not supported</pre>
  </li>
  <li>
<pre>The &quot;To&quot; and and &quot;From&quot; fields of the message indexes do NOT contain CRCs</pre>
  </li>
</ul>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="Acronyms:">Acronyms:</a></u></h3>
<pre>ANSI            American National Standards Institute
ASCII           American Standard Code for Information Interchange
BBS             Bulletin Board System
C               The C programming language as defined by ANSI X3.159-1989
CR              Carriage Return character (ASCII 13)
CRC             Cyclic Redundancy Check
CRC-16          Standard 16-bit CRC using 1021h polynomial (seed 0)
CRC-32          Standard 32-bit CRC using EDB88320h polynomial (seed -1)
CRLF            Carriage Return character followed by a Line Feed character
FSC             FidoNet Standards Commitee (FTS proposal)
FTN             FidoNet Technology Network
FTS             FidoNet Technical Standard
LF              Line Feed character (ASCII 10)
QWK             Compressed message packet format for message reading/networking
RFC             Request for Comments
SMB             Synchronet Message Base
UT              Universal Time (formerly called &quot;Greenwhich Mean Time&quot;)</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="Data types">Data types</a></u></h3>
<pre>uchar           Unsigned 8-bit value (0 through 255).
                C example:</pre>
<pre>                #define uchar unsigned char
</pre>
<pre>short           Signed 16-bit value (-32768 through 32767).
                &quot;short&quot; is a C keyword indicating &quot;short int&quot;.
</pre>
<pre>ushort          Unsigned 16-bit value (0 through 65535).
                C example:</pre>
<pre>                #define ushort unsigned short
</pre>
<pre>ulong           Unsigned 32-bit value (0 through 4294967295).
                C example:</pre>
<pre>                #define ulong unsigned long
</pre>
<pre>time_t          Unsigned 32-bit value.
                Seconds since 00:00 Jan 01 1970 (Unix format).
                Used for all time/date storage in SMB as part of the when_t
                data type. This time format will support dates through the year
                2105.
                time_t is defined by ANSI C as a long (signed) which can
                limit its date support to the year 2038 depending on the
                library routines used.
</pre>
<pre>ASCII           String (aka character array) of 8-bit ASCII characters.
                Characters with the bit 7 set (80h through FFh) represent
                the IBM PC extended ASCII character set. When data or header
                fields of this type are stored in the header, a NULL
                terminator may or may not be present.
                C example:</pre>
<pre>                uchar str[80];
</pre>
<pre>ASCIIZ          ASCII string with (non-optional) NULL terminator.
                C example:</pre>
<pre>                uchar str[81];

nulstr          ASCII string immediately terminated by NULL.
                C example:</pre>
<pre>                uchar *nulstr=&quot;&quot;;
</pre>
<pre>undef           Data buffer with undefined contents.
                C example:</pre>
<pre>                uchar buf[BUF_LEN];</pre>
<pre>when_t          Date/Time stamp including time-zone adjustment information.
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    time_t  time;   // Time stamp (in local time)
                    short   zone;   // Zone constant or Minutes (+/-) from UT</pre>
<pre>                    } when_t;</pre>
<pre>                time:</pre>
<pre>                A time value of 0 is invalid and indicates an uninitialized
                time stamp.</pre>
<pre>                Time stamps are always stored in universal time. i.e.
                Regardless of what the local time zone is, Jan 1st 1994 00:00
                will always be stored as 2D24BD00h.</pre>
<pre>                zone:</pre>
<pre>                If the zone is in the range -720 to +720, it represents the
                number of minutes east or west of UT. Values in this range
                should only be used for time zones not otherwise represented
                here.</pre>
<pre>                If the zone is greater than 720 or less than -720, then the
                following bits have special meaning:</pre>
<pre>                (1&lt;&lt;12)         // Non-US time zone     (east of UT)
                (1&lt;&lt;13)         // Non-US time zone     (west of UT)
                (1&lt;&lt;14)         // U.S. time zone
                (1&lt;&lt;15)         // Daylight savings</pre>
<pre>                The lower 12 bits (0 through 11) contain the number of minutes
                east or west of UT (not accounting for daylight savings).

                If the time zone is one specified in the U.S. Uniform Time Act,
                the following values represent the zone:</pre>
<pre>                AST 0x40F0      // Atlantic             (-04:00)
                EST 0x412C      // Eastern              (-05:00)
                CST 0x4168      // Central              (-06:00)
                MST 0x41A4      // Mountain             (-07:00)
                PST 0x41E0      // Pacific              (-08:00)
                YST 0x421C      // Yukon                (-09:00)
                HST 0x4258      // Hawaii/Alaska        (-10:00)
                BST 0x4294      // Bering               (-11:00)</pre>
<pre>                With bit 15 set, the following values represent the same zone
                with the presence of daylight savings:</pre>
<pre>                ADT 0xC0F0      // Atlantic             (-03:00)
                EDT 0xC12C      // Eastern              (-04:00)
                CDT 0xC168      // Central              (-05:00)
                MDT 0xC1A4      // Mountain             (-06:00)
                PDT 0xC1E0      // Pacific              (-07:00)
                YDT 0xC21C      // Yukon                (-08:00)
                HDT 0xC258      // Hawaii/Alaska        (-09:00)
                BDT 0xC294      // Bering               (-10:00)</pre>
<pre>                The following non-standard time zone specifications may also be
                used:</pre>
<pre>                MID 0x2294      // Midway               (-11:00)
                VAN 0x21E0      // Vancouver            (-08:00)
                EDM 0x21A4      // Edmonton             (-07:00)
                WIN 0x2168      // Winnipeg             (-06:00)
                BOG 0x212C      // Bogota               (-05:00)
                CAR 0x20F0      // Caracas              (-04:00)
                RIO 0x20B4      // Rio de Janeiro       (-03:00)
                FER 0x2078      // Fernando de Noronha  (-02:00)
                AZO 0x203C      // Azores               (-01:00)
                LON 0x1000      // London               (+00:00)
                BER 0x103C      // Berlin               (+01:00)
                ATH 0x1078      // Athens               (+02:00)
                MOS 0x10B4      // Moscow               (+03:00)
                DUB 0x10F0      // Dubai                (+04:00)
                KAB 0x110E      // Kabul                (+04:30)
                KAR 0x112C      // Karachi              (+05:00)
                BOM 0x114A      // Bombay               (+05:30)
                KAT 0x1159      // Kathmandu            (+05:45)
                DHA 0x1168      // Dhaka                (+06:00)
                BAN 0x11A4      // Bangkok              (+07:00)
                HON 0x11E0      // Hong Kong            (+08:00)
                TOK 0x121C      // Tokyo                (+09:00)
                SYD 0x1258      // Sydney               (+10:00)
                NOU 0x1294      // Noumea               (+11:00)
                WEL 0x12D0      // Wellington           (+12:00)

fidoaddr_t      FidoNet address stored as four ushorts that represent the zone,
                network, node, and point (in that order).
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    ushort zone,
                           net,
                           node,
                           point;</pre>
<pre>                    } fidoaddr_t;
</pre>
<pre>typestr_t       ASCIIZ string with ushort type prefix.
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    ushort  type;   // Specifier for type of 'str'
                    uchar   str[];  // ASCIIZ filename or other string data</pre>
<pre>                    } typestr_t;
</pre>
<pre>mattach_t       File attachment information with type prefix, translation
                string, and filename.
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    ushort  type;   // Attachment type
                    ushort  xlat[]; // Translations of data in attachment
                    uchar   str[];  // ASCIIZ filename</pre>
<pre>                    } mattach_t;</pre>
<pre>vattach_t       Video file attachment information with type, compression,
                translation string, and filename.
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    ushort  type;   // Attachment type
                    ushort  comp;   // Compression method
                    ushort  xlat[]; // Translations of data in attachment
                    uchar   str[];  // ASCIIZ filename</pre>
<pre>                    } vattach_t;

mtext_t         Message text with translation string prefix.
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    ushort  xlat[]; // Translations of text
                    uchar   text[]; // Actual text data</pre>
<pre>                    } mtext_t;
</pre>
<pre>ftext_t         Formatted message text with translation string prefix and
                format type.
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    ushort  type;   // See Image Types for valid types
                    ushort  xlat[]; // Translations of data
                    uchar   data[]; // Actual formatted text data</pre>
<pre>                    } ftext_t;
</pre>
<pre>membed_t        Embedded data with type prefix, translation string, and ASCIIZ
                description.
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    ushort  type;   // Specifier for type of 'dat'
                    ushort  xlat[]; // Translations of embedded data
                    uchar   name[]; // ASCIIZ char description of embedded data
                    uchar   dat[];  // Binary data</pre>
<pre>                    } membed_t;</pre>
<pre>vembed_t        Embedded video data with type, compression method, translation
                string, and ASCIIZ description.
                C example:</pre>
<pre>                typedef struct {</pre>
<pre>                    ushort  type;   // Specifier for type of 'dat'
                    ushort  comp;   // Compression method
                    ushort  xlat[]; // Translations of embedded data
                    uchar   name[]; // ASCIIZ char description of embedded data
                    uchar   dat[];  // Binary data</pre>
<pre>                    } vembed_t;</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="File Formats">File Formats</a></u></h2>
<h3><u><a name="Index File (*.SID)">Index File (*.SID)</a></u></h3>
<pre>The index file for each message base contains one record per message in the
base. Each record is fixed length using the following format:

<b><u>Index Record:</u></b>

<i>C example:</i>

typedef struct {

    ushort  to;     // 16-bit CRC of recipient name (lower case) or user number
    ushort  from;   // 16-bit CRC of sender name (lower case) or user number
    ushort  subj;   // 16-bit CRC of title/subject (lower case)
    ushort  attr;   // attributes (MSG_PRIVATE, MSG_READ, etc. flags)
    ulong   offset; // byte offset of message header in header file
    ulong   number; // message serial number (1 based)
    time_t  time;   // import date/time stamp (Unix format)

    } idxrec_t;
</pre>
<pre><b><font SIZE="2">Example file dump (16 messages starting with message number 15):</font></b></pre>
<pre>000000 36 4F 13 07 2A 77 00 00 20 00 00 00 0F 00 00 00
000010 BE 62 76 2C 36 4F 46 0A 7F B2 00 00 20 01 00 00
000020 10 00 00 00 C7 29 78 2C 36 4F 70 6F 46 FF 00 00
000030 20 02 00 00 11 00 00 00 AD D3 7A 2C 70 6F 13 07
000040 46 FF 00 00 20 03 00 00 12 00 00 00 D6 F8 7F 2C
000050 36 4F E1 EA E7 E9 00 00 20 04 00 00 13 00 00 00
000060 1E 7B 85 2C 37 0D 2E DF 4D 79 00 00 20 05 00 00
000070 14 00 00 00 5C E1 A1 2C 90 54 2D 5A 86 62 00 00
000080 20 06 00 00 15 00 00 00 39 2E A2 2C 70 6F 1A 8B
000090 46 FF 00 00 20 07 00 00 16 00 00 00 D0 7B A8 2C
0000A0 2E DF 1A 8B 4D 79 00 00 20 08 00 00 17 00 00 00
0000B0 FF 7B A8 2C B4 D9 35 7C 23 B1 00 00 20 09 00 00
0000C0 18 00 00 00 CE D4 BA 2C 36 4F BC D8 B2 E7 00 00
0000D0 20 0A 00 00 19 00 00 00 14 5F C3 2C BA A8 4E B0
0000E0 67 76 00 00 20 0B 00 00 1A 00 00 00 6F 89 C3 2C
0000F0 36 4F 0C 01 19 9C 00 00 20 0C 00 00 1B 00 00 00
000100 F8 30 C6 2C 36 4F FA 48 0E 55 00 00 20 0D 00 00
000110 1C 00 00 00 6A 94 D3 2C 36 4F F1 CE CF A2 00 00
000120 20 0E 00 00 1D 00 00 00 53 DB D5 2C 8D A6 21 CE
000130 F7 AB 00 00 20 0F 00 00 1E 00 00 00 31 29 DC 2C</pre>
<pre>
<b><u>Field descriptions:</u></b></pre>
<pre><b>To:</b>
The 'To' field is the CRC-16 of the name of the intended recipient agent of
this message or the intended recipient's user number. If the CRC is stored, the
text must be converted to lower case (A-Z changed to a-z) before the CRC is
calculated. If the message is forwarded to another agent, the original or new
index record must be changed to contain the CRC-16 of the new recipient name or
user number. This field must always contain the recipient user number for local
e-mail on a Synchronet BBS. Outbound netmail stored in the Synchronet local
e-mail message base will contain 0 in this field.</pre>
<pre><b>From:</b>
This field, similar to the 'To' field, contains the CRC-16 of the name of the
sending agent of this message or the sender's user number. If the CRC is
stored, the text must be converted to lower case (A-Z changed to a-z) before
the CRC is calculated. If the message is forwarded to another agent, the
original or new index record must be changed to contain the CRC-16 of the new
sender name or user number. If the message was imported into the local e-mail
message base on a Synchronet BBS via netmail, this field will contain 0.</pre>
<pre><b>Subj:</b>
The 'Subj' field contains the CRC-16 of the message's subject. The subject
must be converted to lower case (A-Z changed to a-z) and all preceeding
&quot;re: &quot;'s and &quot;re:&quot;'s removed before calculating the CRC-16.</pre>
<pre><b>Attr:</b>
This ushort is a bit field of the specific attributes for this message.
It is a clone of the 'attr' element of the msghdr_t structure.</pre>
<pre><b>Offset:</b>
This ulong is the offset (in bytes) in the header file for this message's
header record.</pre>
<pre><b>Number:</b>
This ulong is the serial number of this message. Valid values are 1 through
0xffffffff. No two index records in the same message base may have the same
message number. All index records must have sequential, but not necessarily
consequetive, message numbers.</pre>
<pre><b>Time:</b>
This field is the date/time stamp the message was imported to or posted in
the message base. It is a clone of the 'when_imported.time' element of the
msghdr_t structure.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="Header File (*.SHD)">Header File (*.SHD)</a></u></h3>
<pre>Each SMB header file is made up of two distinct sections: base header records
and message header records (usually the bulk of the file).</pre>
<pre><b><u>Base Header Records:</u></b>

Base header records are blocks of data that apply to the entire message base
and are of variable length. This specification defines only one base header
record, the &quot;Status info&quot; (smbstatus_t) record. This status info record must be
the first base header record in the file (offset 0) and must be modified if 
additional base header records are added.</pre>
<pre>Additional header records allow other developers to store configuration and
status information particular to their application needs. It also allows for
future header record definitions as part of this specification without causing
backward compatibility issues.</pre>
<pre>Each base header record contains a fixed length portion (smbhdr_t) and an
optional variable length portion.</pre>
<pre>Whenever a base header record is read or updated (written), it must first
be successfully locked and subsequently unlocked (using the file system record
locking facilities).</pre>
<pre>The first base header record (Status Info) is used as a semaphore when writing
to the message index (.SID) file and, when using the Hyper Allocation storage
method, writing to the message data (.SDT) file. This record must be
successfully locked before writing and subsequently unlocked. This is to insure
that multiple applications simultaneously writing to the same message base
does not result in corrupted data.
</pre>
<pre><b><u>Message Header Records:</u></b>

Following the last base header record is the first message header record. Each
header record is stored in one or more 256 byte blocks. There must be exactly
one active message header record for every index record in the index file.
(Note: This does not include deleted message headers that have not been
overwritten by a new message header).</pre>
<pre>Each message header record contains a fixed length portion (msghdr_t), a list
of zero or more fixed length data fields (dfield_t), and a list of three or
more variable length header fields (hfield_t).</pre>
<pre>The value of the data stored in the zero or more unused bytes of the last
header record block have an undefined value, though whenever possible
developers should initialize to binary zero for human readability.</pre>
<pre>Whenever a message header record is read or updated (written), it must first
be successfully locked and subsequently unlocked.


<b><u>Base Header Record (Fixed Portion):</u></b>

<i>C example:</i></pre>
<pre>typedef struct {</pre>
<pre>    uchar   id[4];          // text or binary unique hdr ID
    ushort  version;        // version number (initially 100h for 1.00)
    ushort  length;         // length including this struct</pre>
<pre>    } smbhdr_t;
</pre>
<pre><b><u>Base Header Record Field Descriptions:</u></b>

<b>Id:</b>
This is a four byte unique ID identifying the type of the base header record.
The bytes may contain any value, but printable ASCII characters are preferred.
The only ID defined in this specification is &quot;SMB^Z&quot; used by the Status Info
base header record.</pre>
<pre><b>Version:</b>
This is a version number of the base header record type. Base header records
of different versions may have different formats or contain different
information. This is to aid the application in determining if the record
is pertinent and if so, to what degree. The Status Info base header record
uses this version field to define the version of the format for the entire
message base (currently 0x121 for version 1.21).</pre>
<pre><b>Length:</b>
This is entire length in bytes of this header record (including both fixed
and variable portions).
</pre>
<pre><b><u>Base Header #1 (Status info) Record (Variable Portion):</u></b>

<i>C example:</i></pre>
<pre>typedef struct {</pre>
<pre>    ulong   last_msg;       // last message number posted or imported
    ulong   total_msgs;     // total messages currently in message base
    ulong   header_offset;  // byte offset to first header record
    ulong   max_crcs;       // Maximum number of CRCs to keep in history
    ulong   max_msgs;       // Maximum number of messages to keep in base
    ushort  max_age;        // Maximum age of messages (days) to keep in base
    ushort  attr;           // Attribute bits</pre>
<pre>    } smbstatus_t;

<b><u>Base Header #1 (Status Info) Record (Variable Portion) Field Descriptions:</u></b></pre>
<pre><b>Last_msg:</b>
This is the serial number of the last message imported or posted into this
message base. The index, header, and data records for this message may possibly
not exist (due to deletion). This field is used for determining the message
number to give to a new message being imported or posted into this message
base. This field must be updated for every message added to the message base.</pre>
<pre><b>Total_msgs:</b>
This is the total number of active messages currently in the message base.
This number should match the number of records in the index (.SID) file
and active header records in the header (.SHD) file. This field must be
updated whenever a message is added to or removed from the message base.</pre>
<pre><b>Header_offset:</b>
This is the byte offset to the first message header record. It is useful
for skipping all the base header records and going directly to the first
message header record.</pre>
<pre><b>Max_crcs:</b>
This is the maximum number of message CRCs to store in the CRC history (.SCH)
file for duplicate message checking. If this field contains 0, then duplicate
message checking is disabled.</pre>
<pre><b>Max_msgs:</b>
This is the preferred maximum number of messages to keep in this message
base as specified by the system operator. It is used by maintenance programs
that trim the message base down by removing old messages. This field should
be ignored by applications importing or posting messages allowing them to
exceed this maximum at will.</pre>
<pre><b>Max_age:</b>
This field is the maximum age (in days) of messages to keep in the message
base. It is used by maintenance programs to purge out-dated messages from
the message base.

<b>Attr:</b>
This is a bit field containing specific attributes (or flags) that may define
the way messages are stored or retrieved from the this message base. The
following attributes are defined:</pre>
<pre>    <b>SMB_EMAIL       (1&lt;&lt;0)</b></pre>
<pre>    Indicates the message base is specifically for messages to or from local
    users. When this bit is set, the idxrec.to and idxrec.from fields will
    contain the user numbers (or 0 for non-user destination/source) instead of
    the CRC-16 of the agent name.</pre>
<pre>    <b>SMB_HYPERALLOC  (1&lt;&lt;1)</b></pre>
<pre>    Indicates the message base uses the Hyper Allocation storage method. This
    bit should not be cleared by an application without first deleting all the
    messages in the message base. This is due to the fact the Hyper Allocation
    is not downward compatible with the Self-packing and Fast Allocation
    storage methods.</pre>
<pre>When used with Synchronet BBS software, a message base must NOT have both of
the above attributes set. The only message base that should have the SMB_EMAIL
attribute set is the DATA\MAIL message base.

<b><u>Base Header #1 (Status info) Record Contents:</u></b>

smbhdr.id=&quot;SMB\x1a&quot;;        // SMB^Z
smbhdr.version=0x121;       // v1.21
smbhdr.length=sizeof(smbhdr_t)+sizeof(smbstatus_t); smbstatus_t status;
</pre>
<pre><b><u>Additional Base Headers:</u></b>

Additional headers from developers must have initial 8 bytes in smbhdr_t
format, length must include size of smbhdr_t, and header_offset of smbstatus_t
must be changed to include the size of the additional header(s).</pre>
<pre><b>Example file dump (base header portion only):</b></pre>
<pre>000000 53 4D 42 1A 20 01 20 00 F4 01 00 00 F4 01 00 00 SMB.............
000010 20 00 00 00 D0 07 00 00 D0 07 00 00 00 00 00 00  ...............</pre>
<pre><b><u>Message Header Record (Fixed portion):</u></b>

<i>C example:</i></pre>
<pre>typedef struct {</pre>
<pre>    uchar   id[4];          // SHD^Z (same for all types and versions)
    ushort  type;           // Message type (this is the definition of type 0)
    ushort  version;        // Version of type (initially 100h for 1.00)
    ushort  length;         // Total length of fixed portion + all fields
    ushort  attr;           // Attributes (bit field) (duplicated in SID)
    ulong   auxattr;        // Auxillary attributes (bit field)
    ulong   netattr;        // Network attributes (bit field)
    when_t  when_written;   // Date/Time message was originally created
    when_t  when_imported;  // Date/Time message was imported (locally)
    ulong   number;         // Message number (unique, not necessarily seq.)
    ulong   thread_orig;    // Original message number in thread
    ulong   thread_next;    // Next message in thread
    ulong   thread_first;   // Number of first reply to this message
    uchar   reserved[16];   // 16 reserved bytes for future use
    ulong   offset;         // Offset for buffer into data file (0 or mod 256)
    ushort  total_dfields;  // Total number of data fields</pre>
<pre>    } msghdr_t;</pre>
<pre>typedef struct {</pre>
<pre>    ushort  type;           // See &quot;Data Field Types&quot; values
    ulong   offset;         // Offset into buffer 
    ulong   length;         // Length of data field in buffer</pre>
<pre>    } dfield_t;</pre>
<pre>typedef struct {</pre>
<pre>    ushort  type;           // See &quot;Header Field Types&quot; for values
    ushort  length;         // Length of buffer
    uchar   dat[length];</pre>
<pre>    } hfield_t;
</pre>
<pre><b>Example file dump (one header record, both fixed and variable length portions):</b></pre>
<pre>000020 53 48 44 1A 00 00 20 01 F5 00 00 00 00 00 00 00 SHD... .........
000030 00 00 00 00 46 DB F7 2C 00 00 7D D7 29 2D 00 00 .......,..}×)-..
000040 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
000050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
000060 00 00 00 00 02 00 00 00 00 00 00 00 4A 01 00 00 ............J...
000070 02 00 4A 01 00 00 53 00 00 00 00 00 13 00 4D 61 ..J...S.......Ma
000080 72 69 61 6E 6E 65 20 4D 6F 6E 74 67 6F 6D 65 72 rianne Montgomer
000090 79 30 00 0C 00 43 61 72 6F 6C 20 47 61 69 73 65 y0...Carol Gaise
0000A0 72 60 00 07 00 46 61 72 6E 68 61 6D A4 00 14 00 r`...Farnham....
0000B0 31 3A 31 33 38 2F 31 30 32 2E 30 20 32 63 66 38 1:138/102.0 2cf8
0000C0 30 35 37 36 A5 00 14 00 31 3A 33 34 33 2F 31 30 0576....1:343/10
0000D0 30 2E 30 20 32 63 66 33 62 39 30 61 A3 00 23 00 0.0 2cf3b90a..#.
0000E0 31 33 38 2F 31 30 32 20 31 20 32 37 30 2F 31 30 138/102 1 270/10
0000F0 31 20 32 30 39 2F 32 30 39 20 31 30 33 2F 30 20 1 209/209 103/0
000100 33 35 35 02 00 02 00 02 00 03 00 08 00 01 00 8A 355.............
000110 00 66 00 00 00 00 00 00 00 00 00 00 00 00 00 00 .f..............</pre>
<pre><b><u>Contents of example header:</u></b></pre>
<pre>id                   SHD^Z
type                 0000h
version              0120h
length               245
attr                 0000h
auxattr              00000000h
netattr              00000000h
when_written         Sat Nov 27 17:57:10 1993
when_imported        Tue Jan 04 15:54:21 1994
number               1
thread_orig          0
thread_next          0
thread_first         0
reserved[16]         
offset               0
total_dfields        2</pre>
<pre>dfield[0].type       00h
dfield[0].offset     0
dfield[0].length     330
dfield[1].type       02h
dfield[1].offset     330
dfield[1].length     83</pre>
<pre>hfield[0].type       00h
hfield[0].length     19
hfield[0]_dat        Marianne Montgomery
hfield[1].type       30h
hfield[1].length     12
hfield[1]_dat        Carol Gaiser
hfield[2].type       60h
hfield[2].length     7
hfield[2]_dat        Farnham
hfield[3].type       A4h
hfield[3].length     20
hfield[3]_dat        1:138/102.0 2cf80576
hfield[4].type       A5h
hfield[4].length     20
hfield[4]_dat        1:343/100.0 2cf3b90a
hfield[5].type       A3h
hfield[5].length     35
hfield[5]_dat        138/102 1 270/101 209/209 103/0 355
hfield[6].type       02h
hfield[6].length     2
hfield[6]_dat        02 00
hfield[7].type       03h
hfield[7].length     8
hfield[7]_dat        01 00 8A 00 66 00 00 00

<b><u>Fixed Portion Field descriptions:</u></b>

<b>Id:</b>
This field (regardless of the header type or version) must always contain the
the string &quot;SHD^Z&quot;. This is to aid in the restoration of a corrupted header
file and give a visual indication of the beginning of a new header record when
viewing dumps of the header file.</pre>
<pre><b>Type:</b>
This is the message header type. Only one type is currently defined by this
specification (type 0). Any and all future header types will have the first
4 fields (10 bytes) in the same format of type 0. This allows other types
(with different lengths) to be skipped because the 4th field (length) will
always be in the same position.</pre>
<pre><b>Version:</b>
This is the version of this header type. This specification defines version
1.21 of message header type 0 (stored as 121h).</pre>
<pre><b>Length:</b>
This is the total length of this message header record (including both fixed
and variable length portions, but NOT including unused block space).</pre>
<pre><b>Attr:</b>
This is a bit field (16-bit) containing basic message attributes (flags) for
this message. An exact duplicate of this field is stored in the index file as
well. They must always match.</pre>
<pre><b>Auxattr:</b>
This is a bit field (32-bit) containing the auxillary attributes (flags) for
this message. The attributes stored in this variable are more specific in
nature and less critical than those in the Attr field.</pre>
<pre><b>Netattr:</b>
This is a bit field (32-bit) containing the network attributes (flags) for this
message. The attributes stored in this variable are related solely to message
networking.</pre>
<pre><b>When_written:</b>
This is the date and time when the message was originally created.</pre>
<pre><b>When_imported:</b>
This is the date and time when the message was posted on or imported into the
local message system.</pre>
<pre><b>Number:</b>
This is the message's unique serial number (from 1 to FFFFFFFFh). This field
is duplicated in the index file. They must always match.

<b>Thread_orig:
</b>If this message is a reply, then this field contains the number of the original
message that was replied to. If this message was not a reply, this field will
contain the value 0.</pre>
<pre><b>Thread_next:
</b>If this message is a reply, and there are later replies to that message
(the message number contained in the Thread_orig field), then this field will
contain the number of the next reply in the chain. If this message is the only
reply to the orignal message, this field will contain the value 0.</pre>
<pre><b>Thread_first:
</b>If there are any replies to this message (after it has been posted), this field
will contain the number of the first reply to this message. If there are no
replies to this message, this field will contain the value 0.</pre>
<pre><b>Reserved:
</b>Unused bytes, reserved for future definition in the message header type 0
specification.</pre>
<pre><b>Offset:
</b>The byte offset into the data file, specifying the start of the buffer for
all data associated with this message. This value must be either 0 or modula
256. When retrieving the actual data portion of data fields, the physical
offset into the file will be the offset of the message data buffer (this field)
plus the offset of the individual data field (msghdr_t.offset+dfield_t.offset).</pre>
<pre><b>Total_dfields:
</b>This field contains the total number of data fields associated with this
message. The value of this field must match the actual number of data fields
stored in the header (dfield_t data types following the fixed portion of the
message header).
</pre>
<pre><b><u>Variable Portion Field descriptions:</u></b>

See the Header Field Type and Data Field Type sections for the descriptions
of the values contained in these fields.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="Message Header Block Allocation (*.SHA)">Message Header Block
Allocation (*.SHA)</a></u></h3>
<pre>If this message base uses the Hyper Allocation storage method (the
SMB_HYPERALLOC bit is set in the smbstatus_t.attr field), then this file is
not created or used.</pre>
<pre>This file contains no header or signature data. Each byte (uchar) in the file
specifies the allocation state of the corresponding 256 byte block in the
header (*.SHD) file. A value of 0 indicates a free header block, and a value of
1 indicates an allocated block. Other non-zero values are undefined.</pre>
<pre>This file must always be opened DENY ALL (non-shareable).</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="Message Data (*.SDT)">Message Data (*.SDT)</a></u></h3>
<pre>This file contains no header or signature data. It contains the text and other
embedded data for the messages in a single message base. The data for each
message always begins on a 256 byte block boundary. The data in the unused
portion of a data block is undefined, but should be initialized to NULL
whenever possible.</pre>
<pre>This file must always be opened DENY NONE (shareable).</pre>
<pre>Data fields of type TEXT_BODY and TEXT_TAIL must have all trailing white space
and control characters removed (i.e. the last character of the data record
must be in the range 21h to FFh). The only exception to this rule, is if the
TEXT_BODY is terminated with multiple contiguous CRLFs, only the last CRLF
should be removed. A CRLF should always be appended to the text data when it is
displayed.</pre>
<pre>When reading from this file, it is a good idea to make sure the message header
for the data being read is currently locked (though no single message header
should be locked for extended durations of time). This will insure that no
other application will write to this portion of the file while it's being
read (read from disk, not displayed).</pre>
<pre>When using the Hyper Allocation storage method, the Status Info message base
header must be successfully locked before writing to this file and subsequently
unlocked.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="Message Data Block Allocation (*.SDA)">Message Data Block
Allocation (*.SDA)</a></u></h3>
<pre>If this message base uses the Hyper Allocation storage method (the
SMB_HYPERALLOC bit is set in the smbstatus_t.attr field), then this file is
not created or used.</pre>
<pre>This file contains no header or signature data. Each word (ushort) in the file
specifies the allocation state of the corresponding 256 byte block in the data
(*.SDT) file. A value of 0 indicates a free block, and a non-zero value
indicates the number of message header records associated with this message
data (most often 1). Each block can be used by up to 65,535 header records.</pre>
<pre>This file must always be opened DENY ALL (non-shareable).</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="CRC history for duplicate message checking (*.SCH)">CRC history
for duplicate message checking (*.SCH)</a></u></h3>
<pre>This file is optional and contains no header or signature data. Each long word
(ulong) in the file contains a CRC-32 of previously posted/imported messages.
These CRCs can be used to check a candidate message for posting/import to be
sure the message isn't a duplicate created by human or program error. The
maximum number of CRCs to store is defined in the first message base header
record (smbstatus_t.max_crcs).</pre>
<pre>The CRC is calculated on the first TEXT_BODY data field before any translations
are applied (e.g. encoding, compression, encryption).</pre>
<pre>This file must always be opened DENY ALL (non-shareable).</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Header Field Types:">Header Field Types:</a></u></h2>
<pre>These are the defined valid values for hfield_t.type:</pre>
<pre>Name     : SENDER
Value    : 00h
Data     : ASCII
Multiple : Yes, order significant
Required : Yes
Summary  : Name of agent that sent this message</pre>
<pre>If blank (0 length or nulstr), assumed &quot;Anonymous&quot;. If multiple SENDER fields
exist, then the message has been forwarded and the order of the fields in the
record must match the forwarding order (chronologically). When forwarding a
message, the original SENDER field should be left intact and new SENDER,
FORWARDED, and RECIPIENT fields added to the end of the record.</pre>
<pre>Name     : SENDERAGENT
Value    : 01h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : AGENT_PERSON or previous SENDERAGENT if exists
Summary  : Type of agent that sent this message</pre>
<pre>If multiple SENDER fields exist, then the message has been forwarded. If any of the
forwarding agents is of a type other than AGENT_PERSON, then this field must
follow that SENDER field to specify the agent type.</pre>
<pre>Name     : SENDERNETTYPE
Value    : 02h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : NET_NONE or previous SENDERNETTYPE if exists
Summary  : Type of network message was sent from</pre>
<pre>If multiple SENDERNETADDR fields are included, a SENDERNETTYPE field should be
included before each to determine what data type the address is stored in.</pre>
<pre>Name     : SENDERNETADDR
Value    : 03h
Data     : undef
Multiple : Yes, order significant
Required : No
Default  : Previous SENDERNETADDR if exists
Summary  : Network address for agent that sent this message</pre>
<pre>The SENDERNETTYPE field indicates the data type of this field. If the
SENDERNETTYPE is of type NET_INTERNET, the local-part of the Internet
address is optional. If the local-part separator character ('@') is omitted,
the SENDER field is assumed to be the local-part of the address.</pre>
<pre>Name     : SENDEREXT
Value    : 04h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : Previous SENDEREXT if exists
Summary  : Extension of sending agent</pre>
<pre>This field is useful for storing the sending agent's extension, when the
agent's extension binds more tightly than the agent's name.</pre>
<pre>For example, Synchronet Multinode BBS Software stores local e-mail with the
sending and receiving agent's user numbers stored as their respective
extensions. This is done so that if a user name changes for some reason,
messages will not &quot;disappear&quot; from the user's mail box.</pre>
<pre>If the SMB_EMAIL status header attribute is set, then the &quot;From&quot; field in the
index must contain the binary value of this field rather than the CRC-16 of the
SENDER (name) field.</pre>
<pre>Name     : SENDERPOS
Value    : 05h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : Previous SENDERPOS if exists
Summary  : Position of sending agent</pre>
<pre>Primarily for documentary purposes, this field contains the position of the
sending agent (i.e. President, Sysop, C.E.O., MIS Director, etc).</pre>
<pre>It can also be useful for getting a message or reply to the intended
recipient when the agent name is not located or is unknown, but the position
of the agent is known and specified.</pre>
<pre>Name     : SENDERORG
Value    : 06h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : Previous SENDERORG if exists
Summary  : Organization name of sending agent</pre>
<pre>Primarily for documentary purposes, this field contains the organization to
which the sending agent belongs (i.e. Microsoft, Joe's BBS, SoCal User's Group,
etc).

Name     : AUTHOR
Value    : 10h
Data     : ASCII
Multiple : Yes
Required : No
Default  : First SENDER
Summary  : Name of agent that created this message</pre>
<pre>This field can only be added by the process that originally creates the
message. It should not be included if same as first SENDER field. If multiple
AUTHOR fields exist, then the message was created by multiple agents and is
considered valid. The order of multiple AUTHOR fields in the record is not
significant.</pre>
<pre>Name     : AUTHORAGENT
Value    : 11h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : SENDERAGENT or previous AUTHORAGENT if exists
Summary  : Type of agent that created this message</pre>
<pre>This field can only be added by the process that originally creates the
message. It should not be included if same as first SENDERAGENT field. If
multiple AUTHOR fields exist, then the message was created by multiple agents
and if the agent type for any of the authors is other than AGENT_PERSON, an
AUTHORAGENT field must follow to specify the agent type.</pre>
<pre>Name     : AUTHORNETTYPE
Value    : 12h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : SENDERNETTYPE or previous AUTHORNETTYPE if exists
Summary  : Type of network this author is member of</pre>
<pre>Name     : AUTHORNETADDR
Value    : 13h
Data     : undef
Multiple : Yes, order significant
Required : No
Default  : SENDERNETADDR or previous AUTHORNETADDR if exists
Summary  : Network address of this author

Name     : AUTHOREXT
Value    : 14h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : SENDEREXT or previous AUTHOREXT if exists
Summary  : Extension of this author</pre>
<pre>Name     : AUTHORPOS
Value    : 15h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : SENDERPOS or previous AUTHORPOS if exists
Summary  : Position of this author</pre>
<pre>Name     : AUTHORORG
Value    : 16h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : SENDERORG or previous AUTHORORG if exists
Summary  : Organization this author belongs to

Name     : REPLYTO
Value    : 20h
Data     : ASCII
Multiple : Yes, but only last is valid
Required : No
Default  : SENDER
Summary  : Name of agent that replies should go to</pre>
<pre>Name     : REPLYTOAGENT
Value    : 21h
Data     : ushort
Multiple : Yes, but only last is valid
Required : No
Default  : SENDERAGENT
Summary  : Type of agent that replies should go to</pre>
<pre>Name     : REPLYTONETTYPE
Value    : 22h
Data     : ushort
Multiple : Yes, but only last is valid
Required : No
Default  : SENDERNETTYPE
Summary  : Type of network that replies should go to</pre>
<pre>Name     : REPLYTONETADDR
Value    : 23h
Data     : undef
Multiple : Yes, but only last is valid
Required : No
Default  : SENDERNETADDR
Summary  : Network address that replies should go to

Name     : REPLYTOEXT
Value    : 24h
Data     : ASCII
Multiple : Yes, but only last is valid
Required : No
Default  : SENDEREXT
Summary  : Extension of agent that replies should go to</pre>
<pre>Name     : REPLYTOPOS
Value    : 25h
Data     : ASCII
Multiple : Yes, but only last is valid
Required : No
Default  : SENDERPOS
Summary  : Position of agent that replies should go to</pre>
<pre>Name     : REPLYTOORG
Value    : 26h
Data     : ASCII
Multiple : Yes, but only last is valid
Required : No
Default  : SENDERORG
Summary  : Organization of agent that replies should go to

Name     : RECIPIENT
Value    : 30h
Data     : ASCII
Multiple : Yes, order significant
Required : Yes
Default  : &quot;All&quot;
Summary  : Name of agent to receive this message</pre>
<pre>If multiple RECIPIENT fields exist, the message has been forwarded and for each
additional RECIPIENT field (after the initial RECIPIENT), there should be a
FORWARDED field. The order of the RECIPIENT fields in the record must match the
order in which the message was sent and forwarded (chronologically).</pre>
<pre>Name     : RECIPIENTAGENT
Value    : 31h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : AGENT_PERSON or previous RECIPIENTAGENT if exists
Summary  : Type of agent to receive this message</pre>
<pre>If multiple RECIPIENT fields exist, the message has been forwarded. If any of
the recipient agents are of a type other than AGENT_PERSON, this field must
follow the RECIPIENT field to specify the agent type.</pre>
<pre>Name     : RECIPIENTNETTYPE
Value    : 32h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : NET_NONE or previous RECIPIENTNETTYPE if exists
Summary  : Type of network to receive this message</pre>
<pre>Name     : RECIPIENTNETADDR
Value    : 33h
Data     : undef
Multiple : Yes, order significant
Required : No
Default  : Previous RECIPIENTNETADDR if exists
Summary  : Address of network to receive this message

Name     : RECIPIENTEXT
Value    : 34h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : Previous RECIPIENTEXT if exists
Summary  : Extension of agent to receive this message</pre>
<pre>If SMB_EMAIL status header attribute is set, then the &quot;To&quot; field in the index
must contain the binary value of this field rather than the CRC-16 of the
RECIPIENT (name) field. This is the case specifically with the local e-mail
message base on a Synchronet BBS.</pre>
<pre>Name     : RECIPIENTPOS
Value    : 35h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : Previous RECIPIENTPOS if exists
Summary  : Position of agent to receive this message</pre>
<pre>Name     : RECIPIENTORG
Value    : 36h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : Previous RECIPIENTORG if exists
Summary  : Type of agent to receive this message

Name     : FORWARDTO
Value    : 40h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Summary  : Name of agent this message is to be forwarded to</pre>
<pre>Name     : FORWARDTOAGENT
Value    : 41h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTAGENT or previous FORWARDTOAGENT if exists
Summary  : Type of agent this message is to be forwarded to</pre>
<pre>Name     : FORWARDTONETTYPE
Value    : 42h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTNETTYPE or previous FORWARDTONETTYPE if exists
Summary  : Type of network this message is to be forwarded to</pre>
<pre>Name     : FORWARDTONETADDR
Value    : 43h
Data     : undef
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTNETADDR or previous FORWARDTONETADDR if exists
Summary  : Network address this message is to be forwarded to

Name     : FORWARDTOEXT
Value    : 44h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTEXT or previous FORWARDTOEXT if exists
Summary  : Extension of agent this message is to be forwarded to</pre>
<pre>Name     : FORWARDTOPOS
Value    : 45h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTPOS or previous FORWARDTOPOS if exists
Summary  : Position of agent this message is to be forwarded to</pre>
<pre>Name     : FORWARDTOORG
Value    : 46h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTORG or previous FORWARDTOORG if exists
Summary  : Organization of agent this message is to be forwarded to</pre>
<pre>Name     : FORWARDED
Value    : 48h
Data     : when_t
Multiple : Yes, order significant
Required : Yes, if forwarded
Summary  : Date/Time this message was forwarded to another agent

Name     : RECEIVEDBY
Value    : 50h
Data     : ASCII
Multiple : Yes, order significant
Required : Yes, if receiving agent is other than RECIPIENT
Summary  : Name of agent that received this message</pre>
<pre>Name     : RECEIVEDBYAGENT
Value    : 51h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTAGENT or previous RECEIVEDBYAGENT if exists
Summary  : Type of agent that received this message</pre>
<pre>Name     : RECEIVEDBYNETTYPE
Value    : 52h
Data     : ushort
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTNETTYPE or previous RECEIVEDBYNETTYPE if exists
Summary  : Type of network that received this message</pre>
<pre>Name     : RECEIVEDBYNETADDR
Value    : 53h
Data     : undef
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTNETADDR or previous RECEIVEDBYNETADDR if exists
Summary  : Network address that received this message

Name     : RECEIVEDBYEXT
Value    : 54h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTEXT or previous RECEIVEDBYEXT if exists
Summary  : Extension of agent that received this message</pre>
<pre>Name     : RECEIVEDBYPOS
Value    : 55h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTPOS or previous RECEIVEDBYPOS if exists
Summary  : Position of agent that received this message</pre>
<pre>Name     : RECEIVEDBYORG
Value    : 56h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Default  : RECIPIENTORG or previous RECEIVEDBYORG if exists
Summary  : Organization of agent that received this message</pre>
<pre>Name     : RECEIVED
Value    : 58h
Data     : when_t
Multiple : Yes, order significant
Required : Yes, if received
Default  : NULL
Summary  : Date/Time this message was received

Name     : SUBJECT
Value    : 60h
Data     : ASCII
Multiple : No
Required : Yes, but may be blank (0 length or nulstr)
Summary  : Subject/title of message</pre>
<pre>Name     : SUMMARY
Value    : 61h
Data     : ASCII
Multiple : No
Required : No
Summary  : Summary of message contents, created by AUTHOR</pre>
<pre>Name     : COMMENT
Value    : 62h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : Comment about this message, created by SENDER</pre>
<pre>This field is useful for adding notes to a message when forwarding to a new
recipient.</pre>
<pre>Name     : CARBONCOPY
Value    : 63h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : List of agents this message was also sent to</pre>
<pre>This field is optional and only for the use of notifying the recipient of who
else received the message.</pre>
<pre>Name     : GROUP
Value    : 64h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : Name of group of users to receive message on recipient system</pre>
<pre>This field is used when sending to a group name across a network, where the
group can be expanded into multiple header records for each agent on the
destination system.</pre>
<pre>Name     : EXPIRATION
Value    : 65h
Data     : when_t
Multiple : No
Required : No
Summary  : Date/Time that this message will expire

Name     : PRIORITY
Value    : 66h
Data     : ulong
Multiple : No
Required : No
Default  : 0
Summary  : Message priority (0 is lowest, FFFFFFFFh is highest)

Name     : FILEATTACH
Value    : 70h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : Name/file specification of attached file(s)</pre>
<pre>Name of attached file(s). Wildcards allowed. MSG_FILEATTACH attribute must be
set. If the MSG_FILEATTACH attribute is set but this field is not included,
the SUBJECT field is assumed to be the filename(s).</pre>
<pre>Name     : DESTFILE
Value    : 71h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Summary  : Destination name for attached file(s)</pre>
<pre>Wildcards allowed. FILEATTACH field must also be included.</pre>
<pre>Name     : FILEATTACHLIST
Value    : 72h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : Name of ASCII list of attached filenames</pre>
<pre>Wildcards not allowed in ASCII list filename. Wildcards allowed in ASCII list.
MSG_FILEATTACH attribute must be set.</pre>
<pre>Name     : DESTFILELIST
Value    : 73h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Summary  : Name of ASCII list of destination filenames</pre>
<pre>Wildcards not allowed in ASCII list filename. Wildcards allowed in ASCII list.</pre>
<pre>Name     : FILEREQUEST
Value    : 74h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : Name of requested file</pre>
<pre>Wildcards allowed. MSG_FILEREQUEST attribute must be set</pre>
<pre>Name     : FILEPASSWORD
Value    : 75h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Summary  : Password for FILEREQUEST</pre>
<pre>Name     : FILEREQUESTLIST
Value    : 76h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : Name of ASCII list of filenames to request</pre>
<pre>Wildcards allowed.</pre>
<pre>Name     : FILEPASSWORDLIST
Value    : 77h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Summary  : Name of ASCII list of passwords for FILEREQUESTLIST

Name     : IMAGEATTACH
Value    : 80h
Data     : mattach_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of attached image file for display</pre>
<pre>MSG_FILEATTACH attribute must be set. See Image Types for valid
mattach_t.type values.</pre>
<pre>Name     : ANIMATTACH
Value    : 81h
Data     : mattach_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of attached graphical animation file for display</pre>
<pre>MSG_FILEATTACH attribute must be set. See Animation Types for valid
mattach_t.type values.</pre>
<pre>Name     : FONTATTACH
Value    : 82h
Data     : mattach_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of attached font definition file</pre>
<pre>MSG_FILEATTACH attribute must be set. See Font Types for valid mattach_t.type
values.</pre>
<pre>Name     : SOUNDATTACH
Value    : 83h
Data     : mattach_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of attached sound file for playback</pre>
<pre>MSG_FILEATTACH attribute must be set. See Sound Types for valid mattach_t.type
values.</pre>
<pre>Name     : PRESENTATTACH
Value    : 84h
Data     : mattach_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of attached presentation definition file</pre>
<pre>MSG_FILEATTACH attribute must be set. See Present Types for valid
mattach_t.type values.

Name     : VIDEOATTACH
Value    : 85h
Data     : vattach_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of attached interleaved video/sound file</pre>
<pre>MSG_FILEATTACH attribute must be set. See Video Types for valid
vattach_t.type values and Video Compression Types for valid vattach_t.comp
values.</pre>
<pre>Name     : APPDATAATTACH
Value    : 86h
Data     : mattach_t
Multiple : Yes, order significant
Required : No
Summary  : Name of attached application data file for process/display</pre>
<pre>MSG_FILEATTACH attribute must be set. See Application Data Types for valid
mattach_t.type values.

Name     : IMAGETRIGGER
Value    : 90h
Data     : typestr_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of image file to trigger for display</pre>
<pre>See Image Types for valid typestr_t.type values.</pre>
<pre>Name     : ANIMTRIGGER
Value    : 91h
Data     : typestr_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of animation file to trigger for display</pre>
<pre>See Animation Types for valid typestr_t.type values.</pre>
<pre>Name     : FONTTRIGGER
Value    : 92h
Data     : typestr_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of font definition file to trigger</pre>
<pre>See Font Types for valid typestr_t.type values.</pre>
<pre>Name     : SOUNDTRIGGER
Value    : 93h
Data     : typestr_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of sound file to trigger for playback</pre>
<pre>See Sound Types for valid typestr_t.type values.</pre>
<pre>Name     : PRESENTTRIGGER
Value    : 94h
Data     : typestr_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of presentation definition file to trigger</pre>
<pre>See Present Types for valid typestr_t.type values.</pre>
<pre>Name     : VIDEOTRIGGER
Value    : 95h
Data     : typestr_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of interleaved video/sound file to trigger</pre>
<pre>See Video Types for valid typestr_t.type values.</pre>
<pre>Name     : APPDATATRIGGER
Value    : 96h
Data     : typestr_t
Multiple : Yes, order significant
Required : No
Summary  : Type and filename of application data file to trigger</pre>
<pre>See Application Data Types for valid typestr_t.type values.

Name     : FIDOCTRL
Value    : A0h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Format   : keyword &quot;:&quot; [&quot; &quot;] appdata
Summary  : FTS/FSC-compliant control information line</pre>
<pre>Any FidoNet FTS/FSC-compliant control information (&quot;kludge&quot;) line that
does not have an equivalent representation here. All data not unique to the
actual control line, including leading and trailing white space, Ctrl-A (01h)
character and terminating CR must be ommited. Defined in FTS-0001.</pre>
<pre>Name     : FIDOAREA
Value    : A1h
Data     : ASCII
Multiple : No
Required : No
Summary  : FTN EchoMail conference name.</pre>
<pre>Defined in FTS-0004.</pre>
<pre>Name     : FIDOSEENBY
Value    : A2h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Format   : net&quot;/&quot;node [&quot; &quot;[net&quot;/&quot;]node] [...]
Summary  : Used to store two-dimensional (net/node) SEEN-BY information</pre>
<pre>Often used in FTN EchoMail environments. Only the actual SEEN-BY data is stored
and SEEN-BY: is stripped along with any leading and trailing white space
characters. Defined in FTS-0004.</pre>
<pre>Name     : FIDOPATH
Value    : A3h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Format   : net&quot;/&quot;node [&quot; &quot;[net&quot;/&quot;]node] [...]
Summary  : Used to store two-dimensional (net/node)</pre>
<pre>Defined in FTS-0004. ^aPATH: is stripped along with any leading and trailing
white space characters.

Name     : FIDOMSGID
Value    : A4h
Data     : ASCII
Multiple : No
Required : No
Format   : origaddr &quot; &quot; serialno
Summary  : MSGID field as specified in FTS-0009.</pre>
<pre>Name     : FIDOREPLYID
Value    : A5h
Data     : ASCII
Multiple : No
Required : No
Format   : origaddr &quot; &quot; serialno
Summary  : REPLY field as specified in FTS-0009.</pre>
<pre>Name     : FIDOPID
Value    : A6h
Data     : ASCII
Multiple : No
Required : No
Format   : pID &quot; &quot; version [&quot; &quot;serialno]
Summary  : Indentification string of program that created this message</pre>
<pre>Defined FSC-0046. &quot;^aPID:&quot; and any white space is not included.</pre>
<pre>Name     : FIDOFLAGS
Value    : A7h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : Used to store the FTN FLAGS kludge information</pre>
<pre>Note that all FLAG options that have binary representation in the message
header must be removed from the FLAGS string prior to storing it. Only the
actual flags option string is stored and ^aFLAGS is stripped along with any
leading and trailing white space characters. Defined in FSC-0053.

Name     : RFC822HEADER
Value    : B0h
Data     : ASCII
Multiple : Yes, order significant
Required : No
Format   : field-name &quot;:&quot; [field-body] [CRLF]
Summary  : Undefined RFC-822 header field</pre>
<pre>Internet Message storage format, that does not have an equivalent
representation here. Folded header fields are allowed. Terminating CRLF may be
ommited.</pre>
<pre>Name     : RFC822MSGID
Value    : B1h
Data     : ASCII
Multiple : No
Required : No
Format   : &quot;&lt;&quot; addr-spec &quot;&gt;&quot;
Summary  : Message-ID field as specified in RFC-822.</pre>
<pre>Name     : RFC822REPLYID
Value    : B2h
Data     : ASCII
Multiple : No
Required : No
Format   : &quot;&lt;&quot; addr-spec &quot;&gt;&quot;
Summary  : In-Reply-To field as specified in RFC-822.

Name     : UNKNOWN
Value    : F0h
Data     : undef
Multiple : Yes
Required : No
Summary  : Undefined header field of undefined type</pre>
<pre>This field is useful for retaining binary header fields (that do not have an
equivalent representation here) between message storage formats.</pre>
<pre>Name     : UNKNOWNASCII
Value    : F1h
Data     : ASCII
Multiple : Yes
Required : No
Summary  : Undefined header field of type ASCII</pre>
<pre>This field is useful for retaining ASCII header fields (that do not have an
equivalent representation here) between message storage formats.</pre>
<pre>Name     : UNUSED
Value    : FFh
Data     : undef
Multiple : Yes
Required : No
Summary  : Unused (deleted) header field</pre>
<pre>The data contained in this header field is of an unknown type and should not be
processed.
</pre>
<pre>Note:
----
Specifically, not defined are the values F000h through FFFFh. These values
are to be used for user or system defined header fields. Digital Dynamics
requests that any developers or organizations that wish to have additional
header fields added to this specification notify Digital Dynamics through any
of the contact methods listed at the beginning of this document.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Data Field Types:">Data Field Types:</a></u></h2>
<pre>These are the defined valid values for dfield_t.type:
</pre>
<pre>Val Name                Data        Description
--- ----                ----        -----------
00h TEXT_BODY           mtext_t     Displayable text (body of message).
                                    Included in duplicate message checking.
                                    All terminating white space and control
                                    characters are to be truncated from data
                                    (except when multiple contiguous CRLFs
                                    terminate the text, only the last CRLF
                                    is removed).</pre>
<pre>01h TEXT_SOUL           mtext_t     Non-displayed text.
                                    Not normally displayed. Not necessarily
                                    displayable.
                                    Included in duplicate message checking.</pre>
<pre>02h TEXT_TAIL           mtext_t     Displayable text (tag/tear/origin lines,
                                    etc).
                                    Not included in duplicate message checking.
                                    All terminating white space and control
                                    characters are to be truncated from data.</pre>
<pre>03h TEXT_WING           mtext_t     Non-displayed text.
                                    Not normally displayed. Not necessarily
                                    displayable.
                                    Not included in duplicate message checking.</pre>
<pre>10h FTEXT_BODY          ftext_t     Formatted equivalent of TEXT_BODY to be
                                    displayed in place of TEXT_BODY if format
                                    is supported. See Image Types for valid
                                    values of ftext_t.type.</pre>
<pre>12h FTEXT_TAIL          ftext_t     Formatted equivalent of TEXT_TAIL to be
                                    displayed in place of TEXT_TAIL if format
                                    is supported. See Image Types for valid
                                    values of ftext_t.type.

20h IMAGEEMBED          membed_t    Type and data of embedded raster image file
                                    for display.
                                    See Image Types for valid membed.type
                                    values.</pre>
<pre>21h ANIMEMBED           membed_t    Type and data of embedded graphical
                                    animation file for display.
                                    See Animation Types for valid membed.type
                                    values.</pre>
<pre>22h FONTEMBED           membed_t    Type and data of embedded font definition
                                    file. See Font Types for valid
                                    membed_t.type values.</pre>
<pre>23h SOUNDEMBED          membed_t    Type and data of embedded sound file for
                                    playback.
                                    See Sound Types for valid membed_t.type
                                    values.</pre>
<pre>24h PRESENTEMBED        membed_t    Type and data of embedded presentation
                                    definition file.
                                    See Present Types for valid membed_t.type
                                    values.</pre>
<pre>25h VIDEOEMBED          vembed_t    Type and data of embedded video/sound file
                                    for playback.
                                    See Video Types for valid vembed_t.type
                                    values.
                                    See Video Compression Types for valid
                                    vembed_t.comp values.</pre>
<pre>26h APPDATAEMBED        membed_t    Type and data of embedded application data
                                    file for process/display.
                                    See Application Data Types for valid
                                    membed_t.type values.</pre>
<pre>FFh UNUSED              undef       Space allocated for future update/expansion
</pre>
<pre>Specifically, not defined are the values F000h through FFFFh. These values
are to be used for user or system defined data fields. Digital Dynamics
requests that any developers or organizations that wish to have additional
data fields added to this specification notify Digital Dynamics through any
of the contact methods listed at the beginning of this document.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Message Attributes:">Message Attributes:</a></u></h2>
<pre>These are the bit values for idxrec_t.attr and msghdr_t.attr:</pre>
<pre>MSG_PRIVATE         (1&lt;&lt;0)  // Private
MSG_READ            (1&lt;&lt;1)  // Read by addressee
MSG_PERMANENT       (1&lt;&lt;2)  // Permanent
MSG_LOCKED          (1&lt;&lt;3)  // Msg is locked, no editing possible
MSG_DELETE          (1&lt;&lt;4)  // Msg is marked for deletion
MSG_ANONYMOUS       (1&lt;&lt;5)  // Anonymous author
MSG_KILLREAD        (1&lt;&lt;6)  // Delete message after it has been read
MSG_MODERATED       (1&lt;&lt;7)  // This message must be validated before export
MSG_VALIDATED       (1&lt;&lt;8)  // This message has been validated by a moderator
</pre>
<pre><b>Auxillary Attributes:</b>

These are the bit values for msghdr_t.auxattr:</pre>
<pre>MSG_FILEREQUEST     (1&lt;&lt;0)  // File request
MSG_FILEATTACH      (1&lt;&lt;1)  // File(s) attached to Msg
MSG_TRUNCFILE       (1&lt;&lt;2)  // Truncate file(s) when sent
MSG_KILLFILE        (1&lt;&lt;3)  // Delete file(s) when sent
MSG_RECEIPTREQ      (1&lt;&lt;4)  // Return receipt requested
MSG_CONFIRMREQ      (1&lt;&lt;5)  // Confirmation receipt requested
MSG_NODISP          (1&lt;&lt;6)  // Msg may not be displayed to user
</pre>
<pre><b>Network Attributes:
</b>
These are the bit values for msghdr_t.netattr:</pre>
<pre>MSG_LOCAL           (1&lt;&lt;0)  // Msg created locally
MSG_INTRANSIT       (1&lt;&lt;1)  // Msg is in-transit
MSG_SENT            (1&lt;&lt;2)  // Sent to remote
MSG_KILLSENT        (1&lt;&lt;3)  // Kill when sent
MSG_ARCHIVESENT     (1&lt;&lt;4)  // Archive when sent
MSG_HOLD            (1&lt;&lt;5)  // Hold for pick-up
MSG_CRASH           (1&lt;&lt;6)  // Crash
MSG_IMMEDIATE       (1&lt;&lt;7)  // Send Msg now, ignore restrictions
MSG_DIRECT          (1&lt;&lt;8)  // Send directly to destination
MSG_GATE            (1&lt;&lt;9)  // Send via gateway
MSG_ORPHAN          (1&lt;&lt;10) // Unknown destination
MSG_FPU             (1&lt;&lt;11) // Force pickup
MSG_TYPELOCAL       (1&lt;&lt;12) // Msg is for local use only
MSG_TYPEECHO        (1&lt;&lt;13) // Msg is for conference distribution
MSG_TYPENET         (1&lt;&lt;14) // Msg is direct network mail</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Translation Types:">Translation Types:</a></u></h2>
<pre>Definition for values of *.xlat[x]:</pre>
<pre>XLAT_NONE           0       // No translation/End of translation list
XLAT_LF2CRLF        1       // Expand sole LF to CRLF
XLAT_ESCAPED        2       // 7-bit ASCII escaping for ctrl and 8-bit data
XLAT_HUFFMAN        3       // Static and adaptive Huffman coding compression
XLAT_LZW            4       // LZW (Lempel-Ziv-Welch) encoding for compression
                            // Terry Welch, IEEE Computer Vol 17, No 6
                            // June 1984, pp 8-19
XLAT_LZC            5       // LZC (modified LZW) encoding for compression
                            // Unix compress program
XLAT_RLE            6       // Run length encoding compression
XLAT_IMPLODE        7       // Implode compression (PKZIP v1.x)
XLAT_SHRINK         8       // Shrink compression (PKZIP v1.x)
XLAT_LZH            9       // LZH dynamic Huffman coding
                            // Haruyasu Yoshizaki, LHarc
                            // November, 1988</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Agent Types:">Agent Types:</a></u></h2>
<pre>AGENT_PERSON        0       // To or from person
AGENT_PROCESS       1       // Unknown process, identified by agent name</pre>
<pre>Agent types E000h through EFFFh are reserved for Synchronet process types
(defined specifically by Digital Dynamics).</pre>
<pre><b>Note:</b>

Specifically not defined are agent types F000h through FFFFh. These values
are to be used for user or system defined agent types. Digital Dynamics
requests that any developers or organizations that wish to have additional
agent types added to this specification notify Digital Dynamics through any
of the contact methods listed at the beginning of this document.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Network Types:">Network Types:</a></u></h2>
<pre>                            // Net Type             Address Format
                            // -----------------------------------
NET_NONE            0       // Locally created      none
NET_UNKNOWN         1       // Unknown              undef
NET_FIDO            2       // FTN network          fidoaddr_t
NET_POSTLINK        3       // PostLink network     none
NET_QWK             4       // QWK based network    ASCII
NET_INTERNET        5       // The Internet         ASCII
NET_WWIV            6       // WWIV based network   ulong
NET_MHS             7       // MHS network          ASCII</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Media Types:">Media Types:</a></u></h2>
<pre><b>Image Types:</b></pre>
<pre>IMAGE_UNKNOWN       0x00    // Use image signature header to determine format
IMAGE_ASC           0x01    // ASCII text/IBM extended ASCII graphics
IMAGE_ANS           0x02    // ANSI X3.64 terminal escape sequences
IMAGE_AVT           0x03    // AVATAR terminal escape sequences
IMAGE_LVI           0x04    // LVI terminal escape sequences
IMAGE_GIF           0x05    // Compuserve Graphics Interchange Format (GIF)
IMAGE_TIF           0x06    // Tagged Image Format (AKA TIFF)
IMAGE_JPG           0x07    // Joint Photographers Electronics Group (JPEG)
IMAGE_T16           0x08    // TrueVision 16-bit bitmap (TGA)
IMAGE_T24           0x09    // TrueVision 24-bit bitmap (TGA)
IMAGE_T32           0x0a    // TrueVision 32-bit bitmpa (TGA)
IMAGE_PCX           0x0b    // ZSoft PaintBrush graphics
IMAGE_BMP           0x0c    // Windows bitmap
IMAGE_RLE           0x0d    // Windows bitmap (compressed)
IMAGE_DIB           0x0e    // Display independant bitmap
IMAGE_PCD           0x0f    // Kodak PhotoCD
IMAGE_G3F           0x10    // Group 3 FAX
IMAGE_EPS           0x11    // Ecapsulated PostScript
IMAGE_RTF           0x12    // Rich text format
IMAGE_RIP           0x13    // Remote Imaging Protocol Script (RIPscrip)
IMAGE_NAP           0x14    // NAPLPS
IMAGE_CDR           0x15    // Corel Draw!
IMAGE_CGM           0x16    // Computer graphics metafile
IMAGE_WMF           0x17    // Windows metafile
IMAGE_DFX           0x18    // Autodesk AutoCAD
IMAGE_IFF           0x19    // Amiga Interchange File Format
</pre>
<pre><b>Animation Types:</b></pre>
<pre>ANIM_UNKNOWN        0       // Use file signature header to determine format
ANIM_FLI            1       // Autodesk animator
ANIM_FLC            2       // Autodesk
ANIM_GL             3       // Grasprt
ANIM_IFF            4       // Amiga Interchange File Format
</pre>
<pre><b>Video Types:</b></pre>
<pre>VIDEO_UNKNOWN       0       // Use file signature header to determine format
VIDEO_QTIME         1       // Apple Quick-time
VIDEO_FQTIME        2       // Apple Flattened Quick-time
VIDEO_AVI           3       // Windows Auto/Video Interleave
VIDEO_ULT           4       // OS/2 Ultimotion

<b>Video Compression Types:</b></pre>
<pre>VCOMP_UNKNOWN       0       // Use file signature header to determine codec
VCOMP_RLE           1       // Apple animation
VCOMP_SMC           2       // Apple graphics
VCOMP_RPZA          3       // Apple video
VCOMP_KLIC          4       // Captain crunch
VCOMP_CVID          5       // CinePak
VCOMP_RT21          6       // Intel indeo R2
VCOMP_IV31          7       // Intel indeo R3
VCOMP_YVU9          8       // Intel YVU9
VCOMP_JPEG          9       // JPEG
VCOMP_MRLE          10      // Microsoft RLE
VCOMP_MSVC          11      // Microsoft video 1
</pre>
<pre><b>Font Types:</b></pre>
<pre>FONT_UNKNOWN        0       // Use file signature header to determine format
FONT_TTF            1       // Windows TrueType
FONT_PFB            2       // PostScript Type 1 Font Binary
FONT_PFM            3       // PostScript Type 1 Font Metric
FONT_AMIGA          4       // Amiga Bitmapped
FONT_AGFA           5       // CompuGraphic Fonts
</pre>
<pre><b>Sound Types:</b></pre>
<pre>SOUND_UNKNOWN       0       // Use file signature header to determine format
SOUND_MOD           1       // MOD format
SOUND_VOC           2       // Sound Blaster VOC format
SOUND_WAV           3       // Windows 3.1 WAV RIFF format
SOUND_MID           4       // MIDI format
SOUND_GMID          5       // General MIDI format (standardized patches)
SOUND_SMP           6       // Turtle Beach SampleVision format
SOUND_SF            7       // IRCAM format
SOUND_AU            8       // Sun Microsystems AU format
SOUND_IFF           9       // Amiga Interchange File Format

<b>Application Data Types:</b></pre>
<pre>APPDATA_UNKNOWN     0       // Use file signature header to determine format
APPDATA_WORDPERFECT 1       // WordPerfect Document
APPDATA_WKS         2       // Lotus 123 Worksheet (?)
APPDATA_WK1         3       // Lotus 123 Worksheet rev 1
APPDATA_WK2         4       // Lotus 123 Worksheet rev 2
APPDATA_WK3         5       // Lotus 123 Worksheet rev 3
APPDATA_DBF         6       // dBase III data file
APPDATA_PDX         7       // Paradox data file
APPDATA_EXCEL       8       // Excel data file
APPDATA_QUATRO      9       // Borland Quatro Pro file
APPDATA_WORD        10      // Microsoft Word</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Message Storage Pseudo Code">Message Storage Pseudo Code</a></u></h2>
<pre>The following is a &quot;C like&quot; pseudo code listing example of adding a message to
an SMB message base. SMBLIB contains C functions to do most of the following
operations. We are supplying this pseudo code as a general definition of the
order of required operations in writing to the message base. Many details have
been left out to simplify the code and to demonstrate only the basic
principles.</pre>
<pre>shd = open ( MSGBASE.SHD , READ/WRITE/DENY_NONE )
sdt = open ( MSGBASE.SDT , READ/WRITE/DENY_NONE )
sid = open ( MSGBASE.SDT , READ/WRITE/DENY_NONE )</pre>
<pre>lock ( shd , smbhdr )
read ( shd , smbstatus )</pre>
<pre>if ( smbstatus.attr &amp; SMB_HYPERALLOC )
    msg.hdr.offset = filelength ( sdt )</pre>
<pre>else {
    number_of_blocks = length_of_message_data / SDT_BLOCK_LEN
    if ( length_of_message_data % SDT_BLOCK_LEN )   /* unevenly divisible */
        number_of_blocks = number_of_blocks + 1</pre>
<pre>    sda = open ( MSGBASE.SDA , READ/WRITE/DENY_ALL )</pre>
<pre>    if ( fast_allocation_mode )
        seek ( sda , END_OF_FILE )</pre>
<pre>    else {
        seek ( sda , BEGINNING_OF_FILE )
        while ( not end_of_file ( sda ) ) {
            read ( sda , allocated , number_of_blocks * 2 )
            if ( allocated = 0 ) {
                seek_backwards ( sda , number_of_blocks * 2 )
                break
            }
        }
    }</pre>
<pre>    msg.hdr.offset = ( current_position ( sda ) / 2 ) * SDT_BLOCK_LEN</pre>
<pre>    allocated = 1</pre>
<pre>    write ( sda , allocated , number_of_blocks * 2 )</pre>
<pre>    close ( sda )
}

seek ( sdt , msg.hdr.offset )</pre>
<pre>write ( sdt , message_data )</pre>
<pre>if ( smbstatus.attr &amp; SMB_HYPERALLOC )
    msg.idx.offset = filelength ( shd )</pre>
<pre>else {
    number_of_blocks = length_of_message_header / SHD_BLOCK_LEN
    if ( length_of_message_header % SHD_BLOCK_LEN )   /* unevenly divisible */
        number_of_blocks = number_of_blocks + 1</pre>
<pre>    sha = open ( MSGBASE.SHA , READ/WRITE/DENY_ALL )</pre>
<pre>    if ( fast_allocation_mode )
        seek ( sha , END_OF_FILE )</pre>
<pre>    else {
        seek ( sha , BEGINNING_OF_FILE )
        while ( not end_of_file ( sha ) ) {
            read ( sha , allocated , number_of_blocks )
            if ( allocated = 0 ) {
                seek_backwards ( sha , number_of_blocks )
                break
            }
        }
    }</pre>
<pre>    msg.idx.offset = ( current_position ( sha ) * SHD_BLOCK_LEN )
    msg.idx.offset = msg.idx.offset + smbstatus.header_offset</pre>
<pre>    allocated = 1</pre>
<pre>    write ( sha , allocated , number_of_blocks )</pre>
<pre>    close ( sha )
}</pre>
<pre>seek ( shd , msg.idx.offset )</pre>
<pre>msg.hdr.number = smbstatus.last_msg+1</pre>
<pre>write ( shd , msg.hdr )</pre>
<pre>smbstatus.total_msgs = smbstatus.total_msgs + 1
smbstatus.last_msg = msg.hdr.number</pre>
<pre>write ( shd , smbstatus )</pre>
<pre>write ( sid , msg.idx )</pre>
<pre>unlock ( shd , smbstatus )</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Message Retrieval Pseudo Code">Message Retrieval Pseudo Code</a></u></h2>
<pre>shd = open ( MSGBASE.SHD , READ/WRITE/DENY_NONE )
sdt = open ( MSGBASE.SDT , READ/WRITE/DENY_NONE )
sid = open ( MSGBASE.SDT , READ/WRITE/DENY_NONE )</pre>
<pre>read ( sid , msg.idx )</pre>
<pre>seek ( shd , msg.idx.offset )</pre>
<pre>lock ( shd , msg.hdr )</pre>
<pre>read ( shd , msg.hdr )</pre>
<pre>seek ( sdt , msg.hdr.offset )</pre>
<pre>read ( sdt , msg.hdr.data_length )</pre>
<pre>unlock ( shd , msg.hdr )</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="SMBUTIL">SMBUTIL</a></u></h2>
<pre>SMBUTIL is a utility that can perform various functions on an SMB message base.
The primary purpose of SMBUTIL is as an example to C programmers of how to use
the SMBLIB functions to access and modify an SMB message base. The complete C
source code for SMBUTIL is included and functions from it can be used or
modified by developers at their own discretion. The following files make up
SMBUTIL:</pre>
<pre>SMBUTIL.EXE     Compiled and linked for 16-bit DOS (ready to run)
SMBUTIL.C       C functions
SMBUTIL.H       C definitions and variable prototypes
SMBUTIL.WAT     Makefile for Watcom C/C++ (type wmake -f smbutil.wat)
SMBUTIL.BOR     Makefile for Borland C/C++ (type make -f smbutil.bor)</pre>
<pre>The usage syntax is as follows:</pre>
<pre>SMBUTIL [/opts] cmd smb_filespec.shd</pre>
<pre>where cmd is one or more of the following:</pre>
<pre>       l[n] = list msgs starting at number n
       r[n] = read msgs starting at number n
       v[n] = view msg headers starting at number n
       k[n] = kill (delete) n msgs
       i&lt;f&gt; = import from text file f
       s    = display msg base status
       c    = change msg base status
       m    = maintain msg base - delete old msgs and msgs over max
       p[k] = pack msg base (k specifies minimum packable Kbytes)</pre>
<pre>where opts is one or more of the following:</pre>
<pre>       a    = always (force) packing
       z&lt;n&gt; = set time zone (n=min +/- from UT or 'EST','EDT','CST',etc)</pre>
<pre>and smb_filespec is the base filename or file specification (wildcards) for the
message base. If wildcards are used, the &quot;.SHD&quot; extension must be specified.</pre>
<pre>An example command line:</pre>
<pre>SMBUTIL MP C:\SBBS\DATA\SUBS\*.SHD</pre>
<pre>would maintain and pack all the message bases found in the C:\SBBS\DATA\SUBS
directory.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="CHKSMB">CHKSMB</a></u></h2>
<pre>CHKSMB is a utility that performs a comprehensive analysis of a message base
to find any possible errors and calculate the number of packable bytes. It does
not &quot;fix&quot; a message base if any errors are found, it only reports the specific
errors (and exits with a non-zero error level). If any errors are reported,
packing the message base with SMBUTIL may rebuild the damaged files. If that
doesn't work, then use FIXSMB as a last resort.</pre>
<pre>C source code for CHKSMB is also included as an example to programmers of how
to use SMBLIB functions.</pre>
<pre>The usage syntax is as follows:</pre>
<pre>CHKSMB [/opts] smb_filespec.shd</pre>
<pre>where opts is one or more of the following:</pre>
<pre>        q   = quiet mode (no beeps)
        s   = stop after an errored message base (for use with wildcards)
        p   = pause after an errored message base (wait for key press)
        t   = don't check for unsupported translation strings (faster)
        e   = display extended information on corrupted messages</pre>
<pre>An example command line:</pre>
<pre>CHKSMB /QP C:\SBBS\DATA\SUBS\*.SHD</pre>
<pre>would check all the message bases in the C:\SBBS\DATA\SUBS directory, without
beeping on errors, and pausing after an errored message base.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="FIXSMB">FIXSMB</a></u></h2>
<pre>FIXSMB is a utility that will rebuild the index and allocation files for a
message base. Since the message headers are not necessarily stored
sequentially, the order of the messages in the index may be changed when the
index is rebuilt. Messages are also re-numbered, so only use this program if
the index is corrupted and the messages are extremely important.</pre>
<pre>C source code for FIXSMB is also included as an example to programmers of how
to use SMBLIB functions.</pre>
<pre>The usage syntax is as follows:</pre>
<pre>FIXSMB [/M] smb_file</pre>
<pre>An example command line:</pre>
<pre>FIXSMB \SBBS\DATA\MAIL</pre>
<pre>Only use the &quot;/M&quot; command line switch if fixing an older Synchronet e-mail
message base (created with SBBS v2.1 or earlier). Once the SMB_EMAIL status
attr is set (&quot;SMBUTIL S&quot; will report a status attr of 1), the &quot;/M&quot; is not
required.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="SMBLIB">SMBLIB</a></u></h2>
<pre>SMBLIB is a library of C functions for accessing and storing messages in an
SMB format message base. It can eliminate much of the development time for
developers that wish to use the library in whole or in part, or use the
functions as examples for their own message base function library. The library
consists of the following files:</pre>
<pre>SMBDEFS.H       Constant definitions, macros, and data types
SMBLIB.H        Library constants and function prototypes
SMBLIB.C        Function definitions
SMBVARS.C       Global variable definitions (doubles as declaration file)</pre>
<pre>For developers to use this library with their program, they must include the
&quot;SMBLIB.H&quot; header file at the top of each C file that uses any of the library
functions, global variables, data types, macros, and constants. This can be
done by simply adding the following line to each .C file:</pre>
<pre>#include &quot;smblib.h&quot;</pre>
<pre>If SMBLIB.H is included, there is no need to include SMBDEFS.H or SMBVARS.C.</pre>
<pre>To link the library functions and variables with a main program, the files
SMBVARS.OBJ and SMBLIB.OBJ must be linked with the main program .OBJ files.
If the operating system is DOS, be sure that all .OBJ files are compiled for
the same memory model.</pre>
<pre>Example MAKEFILEs for compiling and linking SMBUTIL with Borland C/C++
(SMBUTIL.BOR) and Watcom C/C++ (SMBUTIL.WAT) are included.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="SMBDEFS.H">SMBDEFS.H</a></u></h3>
<pre>The SMBDEFS.H file contains important constant definitions and data types (also
defined in this document). If ever this document and SMBDEFS.H are inconsistent
with each other, then SMBDEFS.H is to be considered correct and this document
in error. If such a discrepency is found, please notifiy Digital Dynamics so it
can be corrected in a future revision of the specification.</pre>
<pre>Most notable of the data types is a structure called smbmsg_t (not defined
in this document). It contains the fixed and variable portions of a message's
header record as well as convenience pointers to the sender's name
(smbmsg_t.to), recipient's name (smbmsg_t.from), network addresses, and more.
If multiple SENDER header fields are included (for example), then smbmsg_t.to
will point to the last SENDER header field in the header record. Convenience
pointers for other data items work in the same fasion if multiple header fields
of the same type exist in the header record.</pre>
<pre>Variables of the smbmsg_t data type (and pointers to variables of smbmsg_t
type) are used as arguments to many of the SMBLIB functions.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="SMBVARS.C">SMBVARS.C</a></u></h3>
<pre>The SMBVARS.C file contains definitions of the global variables used by the
SMBLIB functions. It is a fairly small file since their are a small number of
global variables (by design). This file is used for both definitions and
declarations, so no &quot;extern&quot; declarations need to be made in developers source
code as long as SMBVARS.C or (preferably) SMBLIB.H is included in the source
code.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="SMBLIB.H">SMBLIB.H</a></u></h3>
<pre>The SMBLIB.H file contains prototypes of all the functions in the SMBLIB.C
file. It is necessary to include this file in C source code if any of the
SMBLIB functions are used. The following C source line will include this file:</pre>
<pre>#include &quot;smblib.h&quot;</pre>
<pre>and should be placed near the top of all C source files that use SMBLIB
functions, variables, constants, or data types.</pre>
<pre>Function prototypes are necessary for compilers to know the correct calling
syntax of a function and detect incorrect usage. Prototypes are also useful
as a quick reference for programmers as to the correct calling syntax of a
specific function.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="SMBLIB.C">SMBLIB.C</a></u></h3>
<pre>The SMBLIB.C file contains the actual SMBLIB library functions. This source
file is not a stand alone program, but instead must be compiled and linked
with a main source file to create the executable program.</pre>
<pre>The functions in this file are organized in a logical order, but their order
is actually irrelevant to the compiling, linking, and execution of the
resulting program.</pre>
<pre>A comment block preceeds each function, explaining what the function does,
how the passed parameters are used, and what the return code (if any)
indicates. A more detailed explanation of each function is included here:</pre>
<pre><b>int smb_open(int retry_time)</b>

The smb_open() function must be called before the message base is accessed
(read from or written to). The parameter, retry_time, is the maximum number
of seconds to wait while retrying to lock the message base header. If
retry_time is 0, then the message base header is not locked or read (this is
called &quot;Fast Open&quot; and should only be used when speed is more important than
checking for compatibility and validity upon opening). The global variable
smb_file must be initialized with the path and base filename of the message
base. This function returns 0 on success, 1 if the .SDT file could not be
opened, 2 if the .SHD file could not be opened, and 3 if the .SID file could
not be opened. If the message base header could not be locked, this function
returns -1. If the message base ID is incorrect, it returns -2. And if the
message base is of an incompatible version, it returns -3.</pre>
<pre>The errno global variable (standard of most C libraries) will most likely
contain the error code for open failure.</pre>
<pre><b>int smb_open_da(int retry_time)</b>

The smb_open_da() function is used to open the data block allocation file for
writing messages to a message base. The parameter, retry_time, is the maximum
number of seconds to wait while retrying to open the file. This function
returns 0 on success. -1 is returned if an open error other than &quot;Access
Denied&quot; is returned from the operating system, and the global variable errno
will contain the error code. -2 is returned if the retry_time has been
reached, and -3 is returned if the file descriptor could not be converted to
a stream by the fdopen() function.</pre>
<pre>fclose(sda_fp) should be called immediately after all necessary file access
has been completed.</pre>
<pre>This function is not used with the Hyper Allocation storage method.

<b>int smb_open_ha(int retry_time)
</b>
The smb_open_ha() function is used to open the header block allocation file for
writing messages to a message base. The parameter, retry_time, is the maximum
number of seconds to wait while retrying to open the file. This function
returns 0 on success. -1 is returned if an open error other than &quot;Access
Denied&quot; is returned from the operating system, and the global variable errno
will contain the error code. -2 is returned if the retry_time has been
reached, and -3 is returned if the file descriptor could not be converted to
a stream by the fdopen() function.</pre>
<pre>fclose(sha_fp) should be called immediately after all necessary file access
has been completed.</pre>
<pre>This function is not used with the Hyper Allocation storage method.</pre>
<pre><b>int smb_create(ulong max_crcs, ulong max_msgs, ushort max_age, ushort attr, int retry_time)</b>

The smb_create() function is used to create a new message base or reset an
existing message base. The parameters max_crcs, max_msgs, max_age, and attr
are used to set the initial status of the message base status header. The
parameter, retry_time is the maximum number of seconds to wait while retrying
to lock the message base header. This functions returns 0 on success or 1 if
the message base header could not be locked.</pre>
<pre><b>int smb_trunchdr(int retry_time)
</b>
The smb_trunchdr() function is used to truncate the header file when packing
the message base and writing the new header information back to the header
file. The parameter, retry_time is the maximum number of seconds to wait while
retrying to truncate the header file. Returns 0 on success, -1 if error was
other than &quot;Access Denied&quot;, or -2 if retry_time reached.</pre>
<pre><b>int smb_locksmbhdr(int retry_time)</b></pre>
<pre>The smb_locksmbhdr() function is used to lock the first message base (status)
header. The parameter, retry_time is the number of seconds to wait while
retrying to lock the header. The smb_unlocksmbhdr() function should always be
used to unlock the header after accessing the message base header (usually
with smb_getstatus() and/or smb_putstatus()). Returns 0 if successful, -1 if
unsuccessful.</pre>
<pre><b>int smb_unlocksmbhdr()
</b>
The smb_unlocksmbhdr() function is used to unlock a previously locked message
base header (using smb_lockmsghdr()). Returns 0 on success, non-zero on
failure.</pre>
<pre><b>int smb_getstatus(smbstatus_t *hdr)
</b>
The smb_getstatus() function is used to read the status message base header
into the hdr structure. Returns 0 on success, 1 on failure.</pre>
<pre><b>int smb_putstatus(smbstatus_t hdr)</b></pre>
<pre>The smb_putstatus() function is used to write the status information to the
first message base header. The parameter hdr, contains the status information
to be written. Returns 0 on success, 1 on failure.</pre>
<pre><b>int smb_getmsgidx(smbmsg_t *msg)</b>

The smb_getmsgidx() function is used to get the byte offset for a specific
message header in the message header file based on the message base index.</pre>
<pre>If msg-&gt;hdr.number is non-zero when this function is called, then the index
will be searched for this message number. If the message number is found in
the index, the msg-&gt;idx.offset is set to the byte offset of the message header
record in the header file and msg-&gt;offset is set to the record offset of the
index record in the index file, and the function returns 0. If the message
number is not found in the index, the function returns 1.</pre>
<pre>If msg-&gt;hdr.number is zero, msg-&gt;idx.offset and msg-&gt;idx.number are obtained
from the index record at record offset msg-&gt;offset. If msg-&gt;offset is an
invalid record offset when this function is called, the function returns 1.
Otherwise, the function returns 0.</pre>
<pre><b>int smb_getlastidx(idxrec_t *idx)</b>

Reads the last index record of the currently open message base into the
idxrec_t structure pointed to by idx. Returns 0 if successful, -1 if the index
is empty or unopened, or -2 if the record can't be read.</pre>
<pre><b>int smb_getmsghdrlen(smbmsg_t msg)</b>

The smb_getmsghdrlen() function is used to calculate the total length of
message header msg including both fixed and variable length portions. This
function returns the length of the header record in bytes.</pre>
<pre><b>long smb_getmsgdatlen(smbmsg_t msg)</b>

The smb_getmsgdatlen() function is used to calculate the total length of the
data for message msg. This function returns the length of all data fields
combined.</pre>
<pre><b>int smb_lockmsghdr(smbmsg_t msg, int retry_time)</b>

The smb_lockmsghdr() function is used to lock the header record for message
msg. The parameter retry_time is the maximum number of seconds to wait while
retrying to lock the header. Returns 0 on success, -1 on failure. The function
smb_unlockmsghdr() should immediately be called after accessing the message
header (usually with smb_getmsghdr() or smb_putmsghdr()).

<b>int smb_getmsghdr(smbmsg_t *msg)</b>

The function smb_getmsghdr() is used to read the header record for message
msg. msg-&gt;idx.offset must be initialized to the byte offset of the header
record in the header file before this function is called. The function
smb_freemsgmem() must be called to free the memory allocated by this function
for the header and data felds. This function returns 0 on success, -1 if
the fixed portion of the message header record could not be read, -2 if the
message header ID was incorrect, -3 if memory could not be allocated, -4
if a data field could not be read, -5 if the fixed length portion of a header
field could not be read, -6 if the variable length portion of a header field
could not be read, -7 if one or more of the mandatory header fields (SENDER,
RECIPIENT, or SUBJECT) are missing, -8 if total_dfields extends beyond the
end of the header record, or -9 if incompatible header version.</pre>
<pre>Several convenience pointers in the msg structure are initialized by this
function to point to the last occurance of the SENDER (msg-&gt;from), RECIPIENT
(msg-&gt;to), SUBJECT (msg-&gt;subj), etc.</pre>
<pre><b>int smb_unlockmsghdr(smbmsg_t msg)</b>

The smb_unlockmsghdr() function is used to unlock a previously locked message
header (with smb_lockmsghdr()). This function returns 0 on success, non-zero
on failure.</pre>
<pre><b>int smb_addcrc(ulong max_crcs, ulong crc, int retry_time)</b>

The smb_addcrc() function is used to add a CRC-32 to the CRC history file
for a message base, automatically checking for duplicates. The parameter
max_crcs should be the max_crcs defined in the status header of the message
base. The parameter crc, is the CRC-32 of the TEXT_BODY and TEXT_SOUL data
fields for the message. The parameter retry_time is the maximum number of
seconds to wait when retrying to open the CRC history file.</pre>
<pre>This function returns -1 if there was an open error, -2 if the retry_time
was reached, -3 if there was a memory allocation error, 1 if the CRC already
exists in the CRC history file (indicating a duplicate message), or 0 on
success (and no duplicate).</pre>
<pre><b>int smb_hfield(smbmsg_t *msg, ushort type, ushort length, void *data)</b>

The smb_hfield() function is used to add a header field to the structure msg.
The parameters type, length, and data, must be specified according to the
header field values listed in this specification. This function returns 0
on success, non-zero on memory allocation error. The function smb_freemsgmem()
must be called to free the memory allocated by this function.</pre>
<pre><b>int smb_dfield(smbmsg_t *msg, ushort type, ulong length)</b>

The smb_dfield() function is used to add a data field to the structure msg.
The parameters type and length must be specified according to the data field
values listed in this specification. This function returns 0 on success,
non-zero on memory allocation error. The function smb_freemsgmem() must be
called to free the memory allocated by this function.</pre>
<pre><b>int smb_addmsghdr(smbmsg_t *msg,smbstatus_t *status,int storage,int retry_time)</b>

The smb_addmsghdr() function is used to add a new message header to the message
header file and update the index file. The msg and status structures are
updated to reflect the new total messages, last message number, etc. The
storage parameter is used to indicate the storage method to use (either
SMB_SELFPACK, SMB_FASTALLOC, or SMB_HYPERALLOC). If the storage type is
SMB_SELFPACK, the header block allocation file will be searched for unused
block(s) to store this header. If the storage type is SMB_FASTALLOC or
SMB_HYPERALLOC, the header is stored at the end of the header file. Returns 0
on success, non-zero on failure. The parameter retry_time is the maximum number
of seconds to wait while retrying to lock and open files.</pre>
<pre><b>int smb_putmsg(smbmsg_t msg)</b>

The smb_putmsg() function calls both the smb_putmsghdr() and smb_putmsgidx()
functions to write the header and index elements of a message to the
appropriate files. Returns 0 on success, non-zero on failure.</pre>
<pre><b>int smb_putmsgidx(smbmsg_t msg)</b>

The smb_putmsgidx() function is used to store a message index in the message
index file. The message index can be for a new message or an existing
message. Returns 0 on success, non-zero on failure.</pre>
<pre><b>int smb_putmsghdr(smbmsg_t msg)</b>

The smb_putmsghdr() function is used to store a message header in the message
header file. The message header can be for a new message or an existing
message. Returns 0 on success, non-zero on failure.</pre>
<pre><b>void smb_freemsgmem(smbmsg_t msg)</b>

Frees allocated memory for the header and data fields in the msg structure.
This function must be called to free the memory allocated by the functions
smb_hfield(), smb_dfield(), and smb_getmsghdr().</pre>
<pre><b>long smb_hdrblocks(ulong length)
</b>
The smb_hdrblocks() function is used to calculate the number of blocks
required to store a message header of length size (in bytes). This function
returns the number of blocks required.</pre>
<pre><b>long smb_datblocks(ulong length)</b></pre>
<pre>The smb_datblocks() function is used to calculate the number of blocks
required to store message data of length size (in byte). This function returns
the number of blocks required.

<b>long smb_allochdr(ulong length)</b>

The smb_allochdr() function is used to search for free blocks to store a
message header of length bytes and mark the free blocks as allocated in the
header allocation file. This function returns the byte offset to the header
record or a negative number on error. The function smb_open_ha() should be
called prior to calling this function and fclose(sha_fp) should be called
after. The function is called from smb_addmsghdr(), so you probably have no
need to call this function directly.</pre>
<pre><b>long smb_fallochdr(ulong length)</b>

The smb_fallochdr() function works exactly the same as the smb_allochdr()
function except it is much faster because the header allocation file is not
searched for free blocks. The function is called from smb_addmsghdr(), so you
probably have no need to call this function directly.</pre>
<pre><b>long smb_hallochdr(ulong header_offset)
</b>
This smb_hallochdr() functions works exactly the same as the smb_fallochdr()
function except the status.header_offset is passed as the argument and the
header allocation (.SHA) file is not updated so smb_open_ha() need not be
called. The function is called from smb_addmsghdr(), so you probably have no
need to call this function directly.</pre>
<pre><b>long smb_allocdat(ulong length, ushort headers)</b></pre>
<pre>The smb_allocdat() function is used to search for free blocks to store length
amount of data for a message. The parameter headers, indicates the number of
message headers that are associated with this data. Normally, the headers
parameter will be 1, unless this message is part of a mass mailing. The offset
to the allocated data blocks is returned, or a negative value on error. The
function smb_open_da() should be called prior to calling this function and
fclose(sda_fp) should be called after.</pre>
<pre><b>long smb_fallocdat(ulong length, ushort headers)
</b>
The smb_fallocdat() function works exactly the same as the smb_allocdat()
function except it is much faster because the data allocation file is not
searched for free blocks.</pre>
<pre><b>long smb_hallocdat()</b>

The smb_hallocdat() function works exactly the same as the smb_hallocdat()
function except no argument is passed and the data allocation file (.SDA) is
not updated so smb_open_da() need not be called.

<b>int smb_incdat(ulong offset, ulong length, ushort headers)
</b>
The smb_incdat() function is used to increment the header counter in the data
allocation file for the data starting at the byte offset and length size in
bytes. The parameter headers, indicates the number of headers to add to the
current allocation value in the data allocation file. Returns 0 on success,
non-zero on failure.</pre>
<pre><b>int smb_freemsg(smbmsg_t msg, smbstatus_t status)
</b>
The smb_freemsg() function is used to free the disk space allocated for the
header and data fields of the message msg. Returns 0 on success, non-zero on
failure. The parameter, status, must be the current status from the message
base header for this message base.</pre>
<pre><b>int smb_freemsgdat(ulong offset, ulong length, ushort headers)</b></pre>
<pre>The smb_freemsgdat() function is used to decrement the data block allocation
records in the data allocation file associated with the data in the data file
by the value of the headers parameter (normally 1). The parameter offset
indicates the byte offset to the beginning of the message data in the data
file and the parameter length is the total length of the message data.
Returns 0 on success, non-zero on failure.</pre>
<pre><b>int smb_freemsghdr(ulong offset, ulong length)
</b>
The smb_freemsghdr() function is used to set the header block allocation
records in the header allocation file to 0 (indicated non-allocated block).
The parameter offset indicates the byte offset to the beginning of the header
record being freed and the parameter length indicates the total length of the
header record. Returns 0 on success, non-zero on failure.</pre>
<pre><b>int smb_stack(int op)</b>

The smb_stack() function is used to save and restore message base information
so that multiple message bases can be open simultaneously. The stack can
save up to 4 message bases (allowing 5 simultaneously open message bases).
The stack is a &quot;last in, first out&quot; storage area for open message bases.
If the op parameter is SMB_STACK_PUSH, smb_stack() will save (push) the current
message base onto the stack. Calling smb_stack(SMB_STACK_POP) will restore
(pop) the most recently pushed message base off the stack. Calling
smb_stack(SMB_STACK_XCHNG) will exchange the most recently pushed message base
and the current message base (replacing the top of the stack with the current
message base).</pre>
<pre><b>void smb_close()
</b>
Closes the header, data, and index files for the currently open message base.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h3><u><a name="Miscellaneous SMBLIB Files">Miscellaneous SMBLIB Files</a></u></h3>
<pre><b>CRC32.H         C header file for CRC-32 calculations</b>

This file contains a static 32-bit CRC table (crc32tbl[]) and a macro (ucrc32)
that uses this table to calculate 32-bit CRCs one byte at a time.</pre>
<pre>Example:</pre>
<pre>    ulong crc=0xffffffff;</pre>
<pre>for(i=0;i&lt;length;i++)
    crc=ucrc32(buf[i],crc);
crc=~crc;
</pre>
<pre><b>CRC16.C         C functions for 16-bit CRC calculations</b></pre>
<pre>This file contains a function (ucrc16), to calculate 16-bit CRCs one byte at a
time and a function (crc16) that uses the ucrc16() function to calculate the
16-bit CRC of an ASCIIZ character string.</pre>
<pre>Example:</pre>
<pre>    ushort crc;</pre>
<pre>crc=crc16(&quot;Text&quot;);

<b>LZH.H           Function prototypes for LZH.C</b>

This file contains function prototypes for the two most important functions
in LZH.C, lzh_encode() and lzh_decode().</pre>
<pre>Example:</pre>
<pre>    uchar str[256],lzh[512];
    long length;</pre>
<pre>strcpy(str,&quot;This is a string of text&quot;);
length=lzh_encode(str,strlen(str),lzh);
lzh_decode(lzh,length,str);
</pre>
<pre><b>LZH.C           C functions for LZH encoding (compression/decompression)</b>

This file contains the functions for encoding and decoding LZH compressed
data. If the macro LZH_DYNAMIC_BUF is defined when this file is compiled,
temporary buffers will be dynamically allocated as opposed to static. This
may be slower than the static buffer method, but frees the allocated memory
after encoding or decoding. If free memory for your application is an issue,
then define this macro when compiling this file.</pre>
<pre>Example (Borland C):</pre>
<pre>bcc -c -DLZH_DYNAMIC_BUF lzh</pre>
<pre>Example (Watcom C):</pre>
<pre>wcc -dLZH_DYNAMIC_BUF lzh</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="SMBLIB Storage Example">SMBLIB Storage Example</a></u></h2>
<pre>#include &quot;smblib.h&quot;
#include &quot;crc16.c&quot;</pre>
<pre>int main(void)
{
    char    str[256]                        // General purpose string
           ,*msg_text=&quot;Hello, world!&quot;       // Message text
           ,nul_buf[SDT_BLOCK_LEN]={0}      // NULL initialized buffer
           ;
    int     i                               // General purpose integer
           ,storage=SMB_SELFPACK            // Default storage method
           ,retry=10                        // Retry for opening/locking files
           ;
    ushort  max_age=0                       // Default maximum age of messages
           ,xlat=XLAT_NONE                  // Translation string
           ,tzone=PST                       // Time zone
           ,copies=1                        // Number of copies of this msg
           ;
    ulong   max_msgs=500                    // Default max number of msgs
           ,max_crcs=0                      // Default max crcs
           ,length                          // Length of msg text
           ,offset                          // Offset to msg text in data file
           ;
    smbmsg_t    msg;                        // Message structure
    smbstatus_t status;                     // Message base status record</pre>
<pre>strcpy(smb_file,&quot;MSGBASE&quot;);                 // We'll use &quot;MSGBASE&quot; for the name
if((i=smb_open(retry))!=0) {                // Can't open!?!
    printf(&quot;smb_open returned %d\n&quot;,i);
    return(1); }</pre>
<pre>if(!filelength(fileno(shd_fp)))             // Message base not created yet
    smb_create(max_crcs                     // Create with default settings
              ,max_msgs
              ,max_age
              ,storage==SMB_HYPERALLOC
                    ? SMB_HYPERALLOC : 0    // SMB_EMAIL if this was e-mail
              ,retry
              );</pre>
<pre>if((i=smb_locksmbhdr(retry))!=0) {          // Can't lock status base header
    printf(&quot;smb_locksmbhdr returned %d\n&quot;,i);
    smb_close();
    return(1); }</pre>
<pre>if((i=smb_getstatus(&amp;status))!=0) {         // Can't read status base header
    smb_unlocksmbhdr();
    smb_close();
    printf(&quot;smb_getstatus returned %d\n&quot;,i);
    return(1); }</pre>
<pre>if(status.attr&amp;SMB_HYPERALLOC)
    storage=SMB_HYPERALLOC;
else
    storage=SMB_SELFPACK;</pre>
<pre>length=strlen(msg_text);                    // Get length of message
length+=sizeof(xlat);                       // Add length of xlat string</pre>
<pre>if(storage==SMB_HYPERALLOC)                 // Allocate space for message text
    offset=smb_hallocdat();
else {
    if((i=smb_open_da(retry))!=0) {
        smb_unlocksmbhdr();
        printf(&quot;smb_open_da returned %d\n&quot;,i);
        smb_close();
        return(1); }
    if(storage==SMB_FASTALLOC)
        offset=smb_fallocdat(length,copies);
    else
        offset=smb_allocdat(length,copies);
    fclose(sda_fp); }</pre>
<pre>fseek(sdt_fp,offset,SEEK_SET);              // Seek to beginning of data block
fwrite(&amp;xlat,sizeof(xlat),1,sdt_fp);        // Write xlat string
fwrite(msg_text,strlen(msg_text),1,sdt_fp); // Write message text
fwrite(nul_buf,SDT_BLOCK_LEN-length         // Write NULLs out to end of block
    ,1,sdt_fp);
fflush(sdt_fp);                             // Flush output buffer
smb_unlocksmbhdr();                         // Unlock status base header</pre>
<pre>memset(&amp;msg,0,sizeof(smbmsg_t));            // Initialize header to NULL
memcpy(msg.hdr.id,&quot;SHD\x1a&quot;,4);             // Always set to SHD^Z
msg.hdr.version=SMB_VERSION;
msg.hdr.when_written.time=time(NULL);
msg.hdr.when_written.zone=tzone;
msg.hdr.when_imported.time=time(NULL);
msg.hdr.when_imported.zone=tzone;
msg.hdr.offset=offset;</pre>
<pre>strcpy(str,&quot;All&quot;);                          // Send message to &quot;All&quot;
if((i=smb_hfield(&amp;msg,RECIPIENT,strlen(str),str))!=0) {
    printf(&quot;smb_hfield returned %d\n&quot;,i);
    smb_freemsgdat(offset,length,copies);
    smb_close();
    return(1); }
strlwr(str);                                // If this were e-mail, idx.to
msg.idx.to=crc16(str);                      // would be the &quot;to&quot; user number

strcpy(str,&quot;Sysop&quot;);                        // Send message from &quot;Sysop&quot;
if((i=smb_hfield(&amp;msg,SENDER,strlen(str),str))!=0) {
    printf(&quot;smb_hfield returned %d\n&quot;,i);
    smb_freemsgdat(offset,length,copies);
    smb_freemsgmem(msg);
    smb_close();
    return(1); }
strlwr(str);                                // If this were e-mail, idx.from
msg.idx.from=crc16(str);                    // would be the &quot;from&quot; user number</pre>
<pre>strcpy(str,&quot;This is a test&quot;);               // Set the message subject/title
if((i=smb_hfield(&amp;msg,SUBJECT,strlen(str),str))!=0) {
    printf(&quot;smb_hfield returned %d\n&quot;,i);
    smb_freemsgdat(offset,length,copies);
    smb_freemsgmem(msg);
    smb_close();
    return(1); }
strlwr(str);
msg.idx.subj=crc16(str);</pre>
<pre>if((i=smb_dfield(&amp;msg,TEXT_BODY,length))!=0) {
    printf(&quot;smb_dfield returned %d\n&quot;,i);
    smb_freemsgdat(offset,length,copies);
    smb_freemsgmem(msg);
    smb_close();
    return(1); }</pre>
<pre>if((i=smb_addmsghdr(&amp;msg,&amp;status,storage,retry))!=0) {
    printf(&quot;smb_addmsghdr returned %d\n&quot;,i);
    smb_freemsgdat(offset,length,copies);
    smb_freemsgmem(msg);
    smb_close();
    return(1); }</pre>
<pre>smb_freemsgmem(msg);                        // Unnecessary if exiting main()
smb_close();                                // Unnecessary if exiting main()
return(0);
}</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="SMBLIB Retrieval Example">SMBLIB Retrieval Example</a></u></h2>
<pre>#include &quot;smblib.h&quot;</pre>
<pre>int main(void)
{
    char        ch;                         // General purpose character
    int         i,                          // General purpose integer
                retry=10;                   // Retry for opening/locking files
    ushort      xlat;                       // Translation string
    ulong       l;                          // General purpose long integer
    smbmsg_t    msg;                        // Message structure</pre>
<pre>strcpy(smb_file,&quot;MSGBASE&quot;);                 // We'll use &quot;MSGBASE&quot; for the name
if((i=smb_open(retry))!=0) {                // Can't open!?!
    printf(&quot;smb_open returned %d\n&quot;,i);
    return(1); }</pre>
<pre>if(!filelength(fileno(shd_fp))) {           // Message base not created yet
    printf(&quot;Empty\n&quot;);
    smb_close();
    return(0); }</pre>
<pre>for(msg.offset=0;!ferror(sid_fp);msg.offset++) {</pre>
<pre>    fseek(sid_fp,msg.offset*sizeof(idxrec_t),SEEK_SET);
    if(!fread(&amp;msg.idx,1,sizeof(idxrec_t),sid_fp))
        break;</pre>
<pre>    if((i=smb_lockmsghdr(msg,retry))!=0) {
        printf(&quot;smb_lockmsghdr returned %d\n&quot;,i);
        break; }
    if((i=smb_getmsghdr(&amp;msg))!=0) {
        smb_unlockmsghdr(msg);
        printf(&quot;smb_getmsghdr returned %d\n&quot;,i);
        break; }
    if((i=smb_unlockmsghdr(msg))!=0) {
        smb_freemsgmem(msg);
        printf(&quot;smb_unlockmsghdr returned %d\n&quot;,i);
        break; }

    printf(&quot;Subj : %s\n&quot;,msg.subj);
    printf(&quot;To   : %s\n&quot;,msg.to);
    printf(&quot;From : %s\n&quot;,msg.from);
    printf(&quot;Date : %s\n&quot;,ctime((time_t *)&amp;msg.hdr.when_written.time));</pre>
<pre>    for(i=0;i&lt;msg.hdr.total_dfields;i++)
        switch(msg.dfield[i].type) {
            case TEXT_BODY:             // Only show BODY and TAIL data fields
            case TEXT_TAIL:
                fseek(sdt_fp,msg.hdr.offset+msg.dfield[i].offset
                    ,SEEK_SET);
                fread(&amp;xlat,sizeof(xlat),1,sdt_fp);
                if(xlat!=XLAT_NONE)     // No translations supported
                    continue;
                for(l=sizeof(xlat);l&lt;msg.dfield[i].length;l++) {
                    ch=fgetc(sdt_fp);
                    if(ch)
                        putchar(ch); }
                printf(&quot;\n&quot;);
                break; }
    printf(&quot;\n&quot;);</pre>
<pre>    smb_freemsgmem(msg); }          // Free memory allocated by smb_getmsghdr()</pre>
<pre>smb_close();
return(0);
}</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="SMBLIB Performance Issues">SMBLIB Performance Issues</a></u></h2>
<pre>Since importing messages is the usually the most time consuming task likely
undertaken by an SMB application, it is also the most susceptable to design
issues that effect performance.</pre>
<pre><b><u>Opening and Closing</u></b>

When importing multiple messages for a single message base, it appears logical
to open the message base, import all the messages, then close it. This indeed
is preferred over opening and closing the message base for each message.</pre>
<pre>When importing multiple messages for possibly non-consecutive message bases,
developers may eaily make the mistake of opening and closing the message base
for each message. This is not necessary and can considerably hinder the
import performance. The easiest solution is to only close the message base and
open a new one if the next message to be imported is not for the same message
base as the previously imported message. Example:</pre>
<pre>smb_file[0]=0;
for(i=0;i&lt;total_messages_to_be_imported;i++) {
    if(stricmp(get_messagebase_for_this_message(i),smb_file)) {
        if(smb_file[0])     /* We've already opened one */
            smb_close();
        strcpy(smb_file,get_messagebase_for_this_message(i));
        smb_open(10); }
    /* Import this message */
    }
if(smb_file[0])
    smb_close();

A more advanced method is to keep multiple message bases open at the same time.
Due to the likely limitation of total file handles on the system, it is
suggested to keep the number of simultaneously open message bases at or below
3. SMBLIB includes the function smb_stack() to easily &quot;push&quot; and &quot;pop&quot; message
bases without closing them (push is the equivalent to &quot;save&quot; and pop is the
equivalent to &quot;restore&quot;). The downside of this function is that you cannot
access message bases on the stack without actually popping them off (in reverse
of the order they were pushed). You can however &quot;exchange&quot; the current message
base with the message base on the top of the stack (most recently pushed).
To intelligently juggle more than two open message bases, the developer should
create their own equivalent of the smb_stack() function so they can access the
message bases on the stack without popping them off. An example of keeping a
maximum of two message bases open using smb_stack():</pre>
<pre>    char last_messagebase[128],new_messagebase[128];</pre>
<pre>smb_file[0]=0;
last_messagebase[0]=0;
for(i=0;i&lt;total_messages_to_be_imported;i++) {
    strcpy(new_messagebase,get_messagebase_for_this_message(i));
    if(stricmp(new_messagebase,smb_file)) {     /* Not current message base */
        if(smb_file[0]) {                       /* We've already opened one */
            if(!stricmp(new_messagebase,last_messagebase)) { /* Same as last */
                strcpy(last_messagebase,smb_file);
                smb_stack(SMB_STACK_XCHNG); }       /* Retore previous base */
            else {
                if(last_messagebase[0]) {
                    smb_stack(SMB_STACK_XCHNG);
                    smb_close();
                    strcpy(last_messagebase,new_messagebase); }
                else {
                    strcpy(last_messagebase,smb_file);
                    smb_stack(SMB_STACK_PUSH); }    /* Save current base */
                strcpy(smb_file,new_messagebase);
                smb_open(10); } }
        else {
            strcpy(smb_file,new_messagebase);
            smb_open(10); } }
    /* Import this message */
    }
if(smb_file[0])
    smb_close();
if(last_messagebase[0]) {
    smb_stack(SMB_STACK_POP);
    smb_close(); }

The second example would be of negligible performance gain over the first
example (6 open operations versus 7) if the messages to import were in the
following order:</pre>
<pre>msg[0] --&gt; msgbase[0]       // 0 opened
msg[1] --&gt; msgbase[1]       // 0 pushed 1 opened
msg[2] --&gt; msgbase[1]
msg[3] --&gt; msgbase[2]       // 1 closed 0 popped 0 closed 2 opened
msg[4] --&gt; msgbase[0]       // 2 pushed 0 opened
msg[5] --&gt; msgbase[2]       // 0 pushed 2 popped (exchanged)
msg[6] --&gt; msgbase[3]       // 2 closed 0 popped 0 closed 3 opened
msg[7] --&gt; msgbase[0]       // 3 pushed 0 opened</pre>
<pre>The second example would be of significant performance gain over the first
example (4 open operations versus 8) if the messages to import were in the
following order:</pre>
<pre>msg[0] --&gt; msgbase[0]       // 0 opened
msg[1] --&gt; msgbase[1]       // 0 pushed 1 opened
msg[2] --&gt; msgbase[0]       // 1 pushed 0 popped (exchanged)
msg[3] --&gt; msgbase[1]       // 0 pushed 1 popped (exchanged)
msg[4] --&gt; msgbase[0]       // 1 pushed 0 popped (exchanged)
msg[5] --&gt; msgbase[2]       // 0 pushed 1 popped (exchanged) 1 closed 2 opened
msg[6] --&gt; msgbase[3]       // 2 pushed 0 popped (exchanged) 0 closed 3 opened
msg[7] --&gt; msgbase[2]       // 3 pushed 2 popped (exchanged)</pre>
<pre>More advanced use of &quot;stack-like&quot; message base file handle storage can easily
reduce the number of open operations, therefore increasing import performance
under more adverse message base ordering conditions.

<b><u>Compression</u></b>

If any message data compression features are offered by the application, it
is important the the application not unnecessarily compress data that will
not save any storage space. While this may seem an obvious statement, please
review the following pseudo-code example:</pre>
<pre>if ( message_data_length &lt; SDT_BLOCK_LEN )
    // Store uncompressed data
else {
    // Compress data
    if ( ( compressed_data_length / SDT_BLOCK_LEN )
        &lt; ( message_data_length / SDT_BLOCK_LEN ) ) // Saves a block or more
        // Store compressed data
    else
        // Store uncompressed data
    }</pre>
<pre>Since the SMB format stores message data in fixed length blocks, there is no
point in storing a message in compressed format if it requires the same number
of blocks as the uncompressed format (i.e. a message that is two blocks in
length in uncompressed format and only a block and a half in length when
compressed should not be stored in compressed format since it still requires
two full blocks of storage). It is important to note that in the above example,
the length of the data translation string was not taken into account in
determining the number of required blocks. Also, the smb_datblocks() function
is normally used in determing the number of required blocks to store a given
data length and it is a little more involved than simply dividing the length of
the data by SDT_BLOCK_LEN.</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Bibliography">Bibliography</a></u></h2>
<pre>Title     : The C Programming Language
Publisher : Prentice Hall
Author    : Brian W. Kernighan and Dennis M. Ritchie</pre>
<pre>Document  : ARPANET Request for Comments (RFC) #822
Title     : Standard for the Format of ARPA Internet text messages
Publisher : SRI International
Author    : David H. Crocker, University of Delaware</pre>
<pre>Document  : FTS-0001
Publisher : FSC
Author    : Randy Bush, Pacific Systems Group</pre>
<pre>Document  : FTS-0004
Title     : EchoMail Specification
Publisher : FSC
Author    : Bob Hartman</pre>
<pre>Document  : FTS-0009
Title     : A standard for unique message identifiers and reply chain linkage
Publisher : FSC
Author    : Jim Nutt</pre>
<pre>Document  : FSC-00046
Title     : A Product Idenfifier for FidoNet Message Handlers
Publisher : FSC
Author    : Joaquim H. Homrighausen</pre>
<pre>Document  : FSC-00053
Title     : Specifications for the ^aFLAGS field
Publisher : FSC
Author    : Joaquim H. Homrighausen</pre>
<p><b><a href="#toc">Back to Table of Contents</a></b></p>
<h2><u><a name="Implementations">Implementations</a></u></h2>
<pre>Product   : Synchronet Multinode BBS Software
Developer : Digital Dynamics
Level     : III
Version   : 2.20</pre>
<pre>Product   : Synchronet/FidoNet Import/Export Utility (SBBSFIDO)
Developer : Digital Dynamics
Level     : III
Version   : 2.23</pre>
<pre>Product   : Synchronet UTI (Universal Text Interface) Driver
Developer : Digital Dynamics
Level     : III
Version   : 2.23</pre>
<pre>Product   : SBBSecho FidoNet Packet Tosser for Synchronet
Developer : Digital Dynamics
Level     : III
Version   : 1.11</pre>
<pre>Product   : NetXpress Internet UUCP for Synchronet
Developer : Merlin Systems
Level     : II
Version   : 1.50</pre>
<pre>Product   : InterEcho FidoNet Packet Tosser
Developer : InterMail Sales Inc
Level     : II
Version   : 1.11</pre>
<p><a href="#top"><b>Back to Top</b></a><!--webbot bot="Include"
U-Include="_borders/bottom.htm" TAG="BODY" startspan -->

<hr>
<p><b><a href="http://www.synchro.net/copyright.html">Copyright</a> © 2000 by </b> <a href="http://www.synchro.net/author.htm"><b>Rob Swindell</b><br>
</a>

<a href="http://www.synchro.net"><font size="2"><br>
Synchronet BBS Software</font></a>  <font size="2">  (Synchronet)
Version 3 is comprised of several documentation,<br>
library, executable, and <a href="http://www.synchro.net/source.html">source code</a> 
files, all of which are covered by the<a href="http://www.fsf.org/copyleft/gpl.html">
<br>
GNU General Public License</a>  with the exception of the following portions
covered by<br>
the <a href="http://www.fsf.org/copyleft/lesser.html">GNU Lesser General Public License</a>:
SMBLIB and XSDK.<br>
<br>
Synchronet Version 2 (for DOS and OS/2) and its source code was released to the<a href="http://www.fsf.org/philosophy/categories.html#PublicDomainSoftware">
<br>
Public Domain</a>  by <a href="ftp://vert.synchro.net/main/sbbs/manifest.txt">Digital Dynamics</a> 
in 1997 and remains Public Domain software today.<br>
Synchronet Version 3 is not Public Domain software.</font></p>
<p align="left"><font size="2"><a href="http://www.synchro.net/author.html">Rob Swindell<br>
</a>PO Box 501<br>Yorba Linda, CA 92885<a href="http://www.synchro.net"><br>
http://www.synchro.net</a>

</font></p>
<p align="left"><font size="2">For the complete Copyright Information please
read the <a href="http://www.synchro.net/copyright.html">Copyright Documentation</a>
.</font></p>

<!--webbot bot="Include" endspan i-CheckSum="55766" -->
</body>

</html>
