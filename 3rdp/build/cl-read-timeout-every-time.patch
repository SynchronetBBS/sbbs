--- ./session/sess_rd.c.orig	2024-01-14 19:55:23.556519000 -0500
+++ ./session/sess_rd.c	2024-01-14 19:55:55.611225000 -0500
@@ -884,28 +884,28 @@
 		return( status );
 		}
 
-	/* Update the stream read timeout to the current user-selected read 
-	   timeout in case the user has changed the timeout setting.
-	   
-	   This isn't perfect in the case of the extremely chatty SSH protocol 
-	   because what looks like a read to the user can involve several reads 
-	   and writes under the hood, and what gets used for those is the 
-	   overall high-level timeout for the operation as a whole, with the 
-	   hidden internal reads and writes using that as their shared setting.  
-	   
-	   For example if the code performs a read and hits an SSH channel 
-	   command it has to send back a response, leading possibly to further 
-	   reads and writes, before it can actually read any data.  So the top-
-	   level read command sets a read timeout and then the much lower-level 
-	   code ends up in a hidden long exchange with the other side using the
-	   same timeout that was set for the overall read before the higher-
-	   level read code gets to complete the actual read */
-	sioctlSet( &sessionInfoPtr->stream, STREAM_IOCTL_READTIMEOUT, 
-			   sessionInfoPtr->readTimeout );
-
 	LOOP_MAX_REV_INITCHECK( dataLength = dataMaxLength, dataLength > 0 )
 		{
 		int byteCount;
+
+		/* Update the stream read timeout to the current user-selected read 
+		   timeout in case the user has changed the timeout setting.
+	   
+		   This isn't perfect in the case of the extremely chatty SSH protocol 
+		   because what looks like a read to the user can involve several reads 
+		   and writes under the hood, and what gets used for those is the 
+		   overall high-level timeout for the operation as a whole, with the 
+		   hidden internal reads and writes using that as their shared setting.  
+	   
+		   For example if the code performs a read and hits an SSH channel 
+		   command it has to send back a response, leading possibly to further 
+		   reads and writes, before it can actually read any data.  So the top-
+		   level read command sets a read timeout and then the much lower-level 
+		   code ends up in a hidden long exchange with the other side using the
+		   same timeout that was set for the overall read before the higher-
+		   level read code gets to complete the actual read */
+		sioctlSet( &sessionInfoPtr->stream, STREAM_IOCTL_READTIMEOUT, 
+				   sessionInfoPtr->readTimeout );
 
 		ENSURES( LOOP_INVARIANT_MAX_REV_XXX( dataLength, 1, dataMaxLength ) );
 				 /* dataLength is decremented by the number of bytes read */
